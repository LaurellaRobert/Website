<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/png" href="favicon.png">
  <title>Robert Laurella</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      min-height: 100vh;
      height: 100vh;
      overflow: hidden;
    }
    .content {
      flex: 0 0 65%;
      max-width: none;
      padding: 0;
      text-align: left;
      display: flex;
      flex-direction: column;
      justify-content: center;
      overflow-y: auto;
    }
    .content-inner {
      width: 85%;
      max-width: 85%;
      margin: 0 auto;
      padding: 40px 40px;
      display: flex;
      flex-direction: column;
      height: 100%;
    }
    .content-header {
      position: sticky;
      top: 0;
      background: inherit;
      z-index: 100;
      padding-bottom: 10px;
    }
    .content-inner h1 {
      margin-top: 0;
      margin-bottom: 15px;
    }
    .content-inner p {
      margin-top: 0;
      line-height: 1.6;
    }
    .tab-content-wrapper {
      flex: 1;
      position: relative;
      padding-top: 10px;
      width: 100%;
      max-width: 100%;
    }
    .animation-panel {
      flex: 0 0 35%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #f9f9f9;
      min-height: 100vh;
      height: 100vh;
      position: relative;
      padding-bottom: 35px;
      box-sizing: border-box;
    }
    .social-links {
      margin-top: 20px;
      display: flex;
      gap: 20px;
    }
    .social-links a {
      color: #333;
      transition: opacity 0.2s;
    }
    .social-links a:hover {
      opacity: 0.6;
    }
    .social-links svg {
      width: 24px;
      height: 24px;
    }
    /* Tab navigation */
    .tab-nav {
      display: flex;
      gap: 0;
      margin-bottom: 25px;
      border-bottom: 2px solid #e0e0e0;
    }
    .tab-button {
      background: none;
      border: none;
      padding: 10px 20px;
      cursor: pointer;
      font-size: 14px;
      color: #666;
      transition: all 0.3s ease;
      border-bottom: 2px solid transparent;
      margin-bottom: -2px;
      font-weight: 500;
    }
    .tab-button:hover {
      color: #333;
    }
    .tab-button.active {
      color: #333;
      border-bottom-color: #333;
    }
    .tab-content {
      position: absolute;
      top: 10px;
      left: 0;
      right: 0;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.2s ease, visibility 0.2s ease;
      overflow-y: auto;
      height: calc(100% - 10px);
      width: 100%;
      max-width: 100%;
    }
    .tab-content.active {
      opacity: 1;
      visibility: visible;
    }

    /* Terminal code display */
    .terminal-code-wrapper {
      position: relative;
      margin-bottom: 20px;
    }
    .terminal-code {
      background: #1a1a1a;
      border-radius: 8px;
      padding: 30px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      line-height: 1.8;
      color: #e0e0e0;
      overflow-x: auto;
      min-height: 500px;
      white-space: pre;
      width: 100%;
      max-width: 100%;
      box-sizing: border-box;
    }
    .terminal-code-run {
      position: absolute;
      top: 12px;
      right: 12px;
      z-index: 10;
      background: transparent;
      border: 1px solid #444;
      border-radius: 4px;
      padding: 6px 12px;
      font-family: 'Courier New', monospace;
      font-size: 11px;
      color: #888;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .terminal-code-run:hover {
      border-color: #9999ff;
      color: #9999ff;
    }
    .terminal-code-run:active {
      transform: scale(0.95);
    }
    .terminal-code-run.ran {
      border-color: #a6e22e;
      color: #a6e22e;
    }
    .terminal-code-run .run-icon {
      font-size: 10px;
    }
    .terminal-code-toggle {
      position: absolute;
      top: 12px;
      right: 80px;
      z-index: 10;
      background: transparent;
      border: 1px solid #444;
      border-radius: 4px;
      padding: 6px 10px;
      font-family: 'Courier New', monospace;
      font-size: 11px;
      color: #66d9ef;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .terminal-code-toggle:hover {
      border-color: #66d9ef;
      background: rgba(102, 217, 239, 0.1);
    }
    .terminal-code-toggle.showing-js {
      color: #a6e22e;
    }
    .terminal-code-toggle.showing-js:hover {
      border-color: #a6e22e;
      background: rgba(166, 226, 46, 0.1);
    }
    .terminal-code.compiling {
      animation: compile-flash 0.8s ease-out;
    }
    @keyframes compile-flash {
      0% { opacity: 1; }
      25% { opacity: 0.6; border-color: #66d9ef; }
      50% { opacity: 1; }
      75% { opacity: 0.8; }
      100% { opacity: 1; }
    }
    .terminal-code .comment {
      color: #666;
    }
    .terminal-code .keyword {
      color: #f92672;
    }
    .terminal-code .type {
      color: #66d9ef;
    }
    .terminal-code .string {
      color: #a6e22e;
    }
    .terminal-code .property {
      color: #e0e0e0;
    }
    .terminal-code .expandable {
      cursor: pointer;
      border-bottom: 1px dashed #666;
      transition: all 0.2s ease;
    }
    .terminal-code .expandable:hover {
      border-bottom-color: #a6e22e;
      color: #c8e6a0;
    }
    .terminal-code .expandable.expanded {
      border-bottom-color: #a6e22e;
    }
    .terminal-code .skill-expansion {
      color: #888;
      font-style: italic;
      display: block;
      margin-left: 0;
      padding-left: 4ch;
      max-width: 60%;
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease, opacity 0.3s ease;
      opacity: 0;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    .terminal-code .skill-expansion.visible {
      max-height: 150px;
      opacity: 1;
    }

    .github-activity {
      margin-top: 30px;
      padding-top: 20px;
      border-top: 1px solid #e0e0e0;
    }
    .github-activity h2 {
      font-size: 14px;
      font-weight: normal;
      color: #666;
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .activity-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .activity-item {
      font-size: 14px;
      color: #666;
      margin-bottom: 12px;
      line-height: 1.5;
    }
    .activity-detail {
      font-size: 13px;
      color: #999;
      margin-top: 3px;
      font-style: italic;
    }
    .activity-item a {
      color: #333;
      text-decoration: none;
    }
    .activity-item a:hover {
      text-decoration: underline;
    }
    .activity-type {
      color: #999;
      font-size: 12px;
    }

    /* Dark mode toggle */
    .theme-toggle {
      position: fixed;
      bottom: 35px;
      left: 20px;
      border: none;
      background: none;
      cursor: pointer;
      padding: 0;
      transition: all 0.3s ease;
      z-index: 1001;
    }
    .theme-toggle:hover {
      opacity: 0.6;
    }
    .theme-toggle svg {
      width: 18px;
      height: 18px;
      fill: #333;
    }

    /* Terminal status bar */
    .terminal-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: #1a1a1a;
      color: #00ff00;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      padding: 6px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-top: 1px solid #333;
      z-index: 1000;
    }
    .terminal-bar-left, .terminal-bar-right {
      display: flex;
      gap: 20px;
      align-items: center;
    }
    .terminal-segment {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .terminal-prompt {
      color: #00ff00;
    }
    .terminal-path {
      color: #66d9ef;
    }
    .terminal-branch {
      color: #f92672;
    }
    .terminal-status {
      color: #a6e22e;
    }
    .terminal-time {
      color: #999;
    }
    body.dark-mode .terminal-bar {
      background: #0a0a0a;
      border-top-color: #222;
    }
    /* Terminal input mode */
    .terminal-bar.input-mode {
      cursor: text;
    }
    .terminal-bar .terminal-input {
      background: transparent;
      border: none;
      outline: none;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      width: 200px;
      padding: 0;
      margin: 0;
    }
    .terminal-bar .terminal-input::placeholder {
      color: #666;
    }
    .terminal-bar .terminal-output {
      color: #a6e22e;
    }
    .terminal-bar .terminal-output.error {
      color: #f92672;
    }
    .terminal-bar .terminal-output a {
      color: #66d9ef;
      text-decoration: none;
    }
    .terminal-bar .terminal-output a:hover {
      text-decoration: underline;
    }
    .terminal-hint {
      color: #666;
      font-size: 11px;
    }
    /* Dark mode styles */
    body.dark-mode {
      background: #1a1a1a;
      color: #e0e0e0;
    }
    body.dark-mode .content {
      color: #e0e0e0;
    }
    body.dark-mode h1 {
      color: #ffffff;
    }
    body.dark-mode p {
      color: #b0b0b0;
    }
    body.dark-mode a {
      color: #ffffff;
    }
    body.dark-mode .social-links a {
      color: #e0e0e0;
    }
    body.dark-mode .social-links svg {
      fill: #e0e0e0;
    }
    body.dark-mode .github-activity {
      border-top-color: #333;
    }
    body.dark-mode .github-activity h2 {
      color: #999;
    }
    body.dark-mode .activity-item {
      color: #999;
    }
    body.dark-mode .activity-item a {
      color: #e0e0e0;
    }
    body.dark-mode .activity-detail {
      color: #666;
    }
    body.dark-mode .theme-toggle svg {
      fill: #e0e0e0;
    }
    body.dark-mode .motion-container svg .tracer {
      fill: #8888dd;
    }
    body.dark-mode .motion-container svg path:not(#motion-path) {
      stroke: #333333;
    }
    body.dark-mode .tab-nav {
      border-bottom-color: #333;
    }
    body.dark-mode .tab-button {
      color: #999;
    }
    body.dark-mode .tab-button:hover {
      color: #e0e0e0;
    }
    body.dark-mode .tab-button.active {
      color: #e0e0e0;
      border-bottom-color: #e0e0e0;
    }
    body.dark-mode .terminal-code {
      background: #0a0a0a;
    }
    body.dark-mode .content-header {
      background: #1a1a1a;
    }

    /* Motion path container */
    .motion-container {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      z-index: 2;
    }
    .motion-container svg {
      width: 400px;
      height: 400px;
      overflow: visible;
    }
    #diamond-group {
      transform-origin: 200px 200px;
    }
    .tracer, .additional-tracer {
      will-change: transform;
    }
    #particle-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }
    .conversion-counter {
      position: absolute;
      bottom: 40px;
      right: 20px;
      font-family: 'Courier New', monospace;
      font-size: 11px;
      color: #999;
      z-index: 10;
      transition: transform 0.2s ease;
    }
    .conversion-counter .counter-value {
      color: #9999ff;
      font-weight: 500;
      display: inline-block;
      min-width: 1ch;
    }
    .conversion-counter.pulse .counter-value {
      animation: counter-pulse 0.4s ease-out;
    }
    .conversion-counter.attention {
      animation: attention-pulse 2s ease-in-out infinite;
    }
    @keyframes counter-pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.4); color: #bbbbff; }
      100% { transform: scale(1); }
    }
    @keyframes attention-pulse {
      0%, 100% { opacity: 0.6; }
      50% { opacity: 1; }
    }
    body.dark-mode .conversion-counter {
      color: #666;
    }
    body.dark-mode .conversion-counter .counter-value {
      color: #9999ff;
    }
    body.dark-mode .animation-panel {
      background: #0a0a0a;
    }
    /* High scores pill */
    .high-scores-pill {
      position: absolute;
      top: 15px;
      left: 15px;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #ddd;
      border-radius: 20px;
      padding: 5px 12px;
      font-family: 'Courier New', monospace;
      font-size: 10px;
      color: #888;
      cursor: pointer;
      z-index: 10;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .high-scores-pill:hover {
      border-color: #9999ff;
      box-shadow: 0 2px 8px rgba(153, 153, 255, 0.12);
    }
    .high-scores-pill svg {
      width: 11px;
      height: 11px;
      stroke: #9999ff;
      fill: none;
      stroke-width: 1.5;
    }
    .high-scores-pill .top-score {
      color: #555;
      font-weight: 600;
    }
    body.dark-mode .high-scores-pill {
      background: rgba(40, 40, 40, 0.9);
      border-color: #444;
      color: #777;
    }
    body.dark-mode .high-scores-pill:hover {
      border-color: #9999ff;
    }
    body.dark-mode .high-scores-pill .top-score {
      color: #ccc;
    }
    /* High scores modal */
    .high-scores-modal {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.98);
      border: 1px solid #e0e0e0;
      border-radius: 12px;
      padding: 24px;
      min-width: 200px;
      z-index: 150;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.2s ease, visibility 0.2s ease;
      box-shadow: 0 4px 24px rgba(0, 0, 0, 0.08);
    }
    .high-scores-modal.visible {
      opacity: 1;
      visibility: visible;
    }
    .high-scores-modal h3 {
      font-family: 'Courier New', monospace;
      font-size: 10px;
      color: #999;
      margin: 0 0 16px 0;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 2px;
      font-weight: 500;
    }
    .high-scores-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .high-scores-list li {
      font-family: 'Courier New', monospace;
      font-size: 12px;
      color: #444;
      padding: 8px 0;
      display: flex;
      justify-content: space-between;
      border-bottom: 1px solid #f0f0f0;
    }
    .high-scores-list li:last-child {
      border-bottom: none;
    }
    .high-scores-list .rank {
      color: #bbb;
      width: 24px;
    }
    .high-scores-list .rank.gold { color: #c9a227; }
    .high-scores-list .rank.silver { color: #8a8a8a; }
    .high-scores-list .rank.bronze { color: #a67c52; }
    .high-scores-list .initials {
      color: #7777cc;
      text-transform: uppercase;
      flex: 1;
      text-align: center;
    }
    .high-scores-list .score {
      color: #444;
      font-weight: 600;
      min-width: 50px;
      text-align: right;
    }
    .high-scores-modal .close-btn {
      position: absolute;
      top: 12px;
      right: 14px;
      background: none;
      border: none;
      color: #ccc;
      font-size: 18px;
      cursor: pointer;
      padding: 0;
      line-height: 1;
      transition: color 0.15s ease;
    }
    .high-scores-modal .close-btn:hover {
      color: #888;
    }
    body.dark-mode .high-scores-modal {
      background: rgba(30, 30, 30, 0.98);
      border-color: #333;
      box-shadow: 0 4px 24px rgba(0, 0, 0, 0.3);
    }
    body.dark-mode .high-scores-modal h3 {
      color: #666;
    }
    body.dark-mode .high-scores-list li {
      color: #ccc;
      border-bottom-color: #333;
    }
    body.dark-mode .high-scores-list .rank {
      color: #555;
    }
    body.dark-mode .high-scores-list .initials {
      color: #9999ff;
    }
    body.dark-mode .high-scores-list .score {
      color: #ccc;
    }
    body.dark-mode .high-scores-modal .close-btn {
      color: #555;
    }
    body.dark-mode .high-scores-modal .close-btn:hover {
      color: #888;
    }
    /* Game over leaderboard */
    .game-over-leaderboard {
      margin-top: 25px;
      width: 100%;
      max-width: 220px;
    }
    .game-over-leaderboard h4 {
      font-family: 'Courier New', monospace;
      font-size: 11px;
      color: #666;
      margin: 0 0 10px 0;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .game-over-leaderboard .high-scores-list li {
      font-size: 11px;
      padding: 4px 0;
    }
    /* Initials input */
    .initials-input-container {
      margin-top: 20px;
      text-align: center;
      display: none;
    }
    .initials-input-container.visible {
      display: block;
    }
    .initials-input-container label {
      font-family: 'Courier New', monospace;
      font-size: 11px;
      color: #a6e22e;
      display: block;
      margin-bottom: 8px;
    }
    .initials-input {
      background: #1a1a1a;
      border: 2px solid #9999ff;
      border-radius: 4px;
      padding: 8px 12px;
      font-family: 'Courier New', monospace;
      font-size: 18px;
      color: #ffcc00;
      text-transform: uppercase;
      text-align: center;
      width: 80px;
      letter-spacing: 4px;
      outline: none;
    }
    .initials-input:focus {
      border-color: #ffcc00;
    }
    .initials-submit {
      background: #9999ff;
      border: none;
      border-radius: 4px;
      padding: 8px 16px;
      font-family: 'Courier New', monospace;
      font-size: 11px;
      color: #0a0a12;
      cursor: pointer;
      margin-left: 8px;
      text-transform: uppercase;
    }
    .initials-submit:hover {
      background: #bbbbff;
    }
    .initials-submit:disabled {
      background: #444;
      cursor: not-allowed;
    }
    /* Pixelated hearts - Zelda style */
    .lives-container {
      position: absolute;
      top: 15px;
      right: 15px;
      display: flex;
      gap: 8px;
      z-index: 10;
    }
    .pixel-heart {
      width: 16px;
      height: 14px;
      position: relative;
      image-rendering: pixelated;
      transition: transform 0.2s ease, opacity 0.3s ease;
    }
    .pixel-heart.lost {
      opacity: 0.2;
      transform: scale(0.9);
    }
    .pixel-heart.losing {
      animation: heart-break 0.5s ease-out;
    }
    @keyframes heart-break {
      0% { transform: scale(1); }
      25% { transform: scale(1.3); }
      50% { transform: scale(0.8) rotate(-10deg); }
      75% { transform: scale(0.9) rotate(5deg); }
      100% { transform: scale(0.9); }
    }
    /* CSS pixel art heart */
    .pixel-heart::before {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      background:
        /* Row 1 - top bumps */
        linear-gradient(to right, transparent 2px, #ff4444 2px, #ff4444 6px, transparent 6px, transparent 10px, #ff4444 10px, #ff4444 14px, transparent 14px) 0 0 / 16px 2px no-repeat,
        /* Row 2 */
        linear-gradient(to right, #ff4444 0px, #ff4444 8px, transparent 8px, transparent 8px, #ff4444 8px, #ff4444 16px) 0 2px / 16px 2px no-repeat,
        /* Row 3 */
        linear-gradient(to right, #ff4444 0px, #ff4444 16px) 0 4px / 16px 2px no-repeat,
        /* Row 4 */
        linear-gradient(to right, transparent 2px, #ff4444 2px, #ff4444 14px, transparent 14px) 0 6px / 16px 2px no-repeat,
        /* Row 5 */
        linear-gradient(to right, transparent 4px, #ff4444 4px, #ff4444 12px, transparent 12px) 0 8px / 16px 2px no-repeat,
        /* Row 6 */
        linear-gradient(to right, transparent 6px, #ff4444 6px, #ff4444 10px, transparent 10px) 0 10px / 16px 2px no-repeat,
        /* Row 7 - bottom point */
        linear-gradient(to right, transparent 7px, #ff4444 7px, #ff4444 9px, transparent 9px) 0 12px / 16px 2px no-repeat;
    }
    .pixel-heart.lost::before {
      background:
        linear-gradient(to right, transparent 2px, #666 2px, #666 6px, transparent 6px, transparent 10px, #666 10px, #666 14px, transparent 14px) 0 0 / 16px 2px no-repeat,
        linear-gradient(to right, #666 0px, #666 8px, transparent 8px, transparent 8px, #666 8px, #666 16px) 0 2px / 16px 2px no-repeat,
        linear-gradient(to right, #666 0px, #666 16px) 0 4px / 16px 2px no-repeat,
        linear-gradient(to right, transparent 2px, #666 2px, #666 14px, transparent 14px) 0 6px / 16px 2px no-repeat,
        linear-gradient(to right, transparent 4px, #666 4px, #666 12px, transparent 12px) 0 8px / 16px 2px no-repeat,
        linear-gradient(to right, transparent 6px, #666 6px, #666 10px, transparent 10px) 0 10px / 16px 2px no-repeat,
        linear-gradient(to right, transparent 7px, #666 7px, #666 9px, transparent 9px) 0 12px / 16px 2px no-repeat;
    }
    /* Shooting star indicator */
    .shooting-star-alert {
      position: absolute;
      top: 40px;
      right: 15px;
      font-family: 'Courier New', monospace;
      font-size: 10px;
      color: #ffcc00;
      z-index: 10;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }
    .shooting-star-alert.visible {
      opacity: 1;
      animation: warning-pulse 0.5s ease-in-out infinite;
    }
    @keyframes warning-pulse {
      0%, 100% { opacity: 0.7; }
      50% { opacity: 1; }
    }

    /* Game Over screen - GBA style */
    .game-over-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #0a0a12;
      z-index: 100;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.5s ease, visibility 0.5s ease;
    }
    .game-over-overlay.visible {
      opacity: 1;
      visibility: visible;
    }
    .game-over-text {
      font-family: 'Courier New', monospace;
      font-size: 32px;
      font-weight: bold;
      color: #ff4444;
      text-transform: uppercase;
      letter-spacing: 4px;
      image-rendering: pixelated;
      text-shadow:
        4px 4px 0 #220000,
        -1px -1px 0 #ff6666;
    }
    .game-over-score {
      font-family: 'Courier New', monospace;
      font-size: 14px;
      color: #9999ff;
      margin-top: 20px;
      letter-spacing: 2px;
    }
    .game-over-score span {
      color: #ffcc00;
      font-weight: bold;
    }
    .game-over-prompt {
      font-family: 'Courier New', monospace;
      font-size: 11px;
      color: #666;
      margin-top: 30px;
      letter-spacing: 1px;
    }
    .game-over-prompt span {
      color: #a6e22e;
    }
    /* Pixel art skull decoration */
    .pixel-skull {
      width: 48px;
      height: 48px;
      margin-bottom: 20px;
      position: relative;
      image-rendering: pixelated;
    }
    .pixel-skull::before {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      background:
        /* Row 1-2: Top of skull */
        linear-gradient(to right, transparent 12px, #e0e0e0 12px, #e0e0e0 36px, transparent 36px) 0 0 / 48px 6px no-repeat,
        /* Row 3: Wider */
        linear-gradient(to right, transparent 6px, #e0e0e0 6px, #e0e0e0 42px, transparent 42px) 0 6px / 48px 6px no-repeat,
        /* Row 4-5: Full width with eyes */
        linear-gradient(to right, transparent 6px, #e0e0e0 6px, #e0e0e0 12px, #0a0a12 12px, #0a0a12 18px, #e0e0e0 18px, #e0e0e0 30px, #0a0a12 30px, #0a0a12 36px, #e0e0e0 36px, #e0e0e0 42px, transparent 42px) 0 12px / 48px 12px no-repeat,
        /* Row 6: Below eyes */
        linear-gradient(to right, transparent 6px, #e0e0e0 6px, #e0e0e0 42px, transparent 42px) 0 24px / 48px 6px no-repeat,
        /* Row 7: Nose area */
        linear-gradient(to right, transparent 12px, #e0e0e0 12px, #e0e0e0 18px, #0a0a12 18px, #0a0a12 30px, #e0e0e0 30px, #e0e0e0 36px, transparent 36px) 0 30px / 48px 6px no-repeat,
        /* Row 8-9: Teeth */
        linear-gradient(to right, transparent 12px, #e0e0e0 12px, #e0e0e0 16px, #0a0a12 16px, #0a0a12 20px, #e0e0e0 20px, #e0e0e0 24px, #0a0a12 24px, #0a0a12 28px, #e0e0e0 28px, #e0e0e0 32px, #0a0a12 32px, #0a0a12 36px, transparent 36px) 0 36px / 48px 12px no-repeat;
    }
    .pixel-skull.animate {
      animation: skull-bounce 0.5s ease-out;
    }
    @keyframes skull-bounce {
      0% { transform: scale(0) rotate(-10deg); }
      50% { transform: scale(1.2) rotate(5deg); }
      100% { transform: scale(1) rotate(0deg); }
    }
    /* Scanlines effect for retro feel */
    .game-over-overlay::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: repeating-linear-gradient(
        0deg,
        rgba(0, 0, 0, 0.15),
        rgba(0, 0, 0, 0.15) 1px,
        transparent 1px,
        transparent 2px
      );
      pointer-events: none;
    }

    /* Projects styles */
    .projects-header {
      margin-bottom: 24px;
    }
    .projects-header p {
      font-size: 14px;
      color: #666;
      margin: 0;
      line-height: 1.5;
    }
    .projects-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
      padding: 4px;
      padding-bottom: 40px;
    }
    .project-card {
      background: #f9f9f9;
      border: 1px solid #e0e0e0;
      border-left: 3px solid #9999ff;
      border-radius: 8px;
      padding: 28px 28px 24px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      transition: border-color 0.2s ease, box-shadow 0.2s ease, border-left-color 0.2s ease;
      cursor: pointer;
      text-decoration: none;
      color: inherit;
    }
    .project-card:hover {
      border-color: #999;
      border-left-color: #7777dd;
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
    }
    .project-card:hover .project-arrow {
      transform: translateX(4px);
      color: #7777dd;
    }
    .project-card:focus {
      outline: 2px solid #333;
      outline-offset: 2px;
    }
    .project-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }
    .project-card-title {
      font-size: 16px;
      font-weight: 600;
      color: #333;
      margin: 0;
    }
    .project-arrow {
      color: #bbb;
      font-size: 16px;
      transition: transform 0.2s ease, color 0.2s ease;
      flex-shrink: 0;
    }
    .project-thesis {
      margin: 0;
      padding-left: 12px;
      border-left: 2px solid #9999ff;
    }
    .project-thesis-label {
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      color: #9999ff;
      margin-bottom: 4px;
    }
    .project-thesis-text {
      font-size: 13px;
      color: #666;
      line-height: 1.5;
      font-style: italic;
      margin: 0;
    }
    .project-desc {
      font-size: 14px;
      color: #555;
      margin: 0;
      line-height: 1.6;
      padding-right: 8px;
    }
    .project-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
      padding-top: 16px;
      border-top: 1px solid #e8e8e8;
    }
    .project-tag {
      font-size: 11px;
      font-family: 'Courier New', monospace;
      color: #666;
      background: #efefef;
      padding: 4px 10px;
      border-radius: 4px;
    }

    /* Dark mode for projects */
    body.dark-mode .projects-header p {
      color: #999;
    }
    body.dark-mode .project-card {
      background: #1a1a1a;
      border-color: #333;
      border-left-color: #7777bb;
    }
    body.dark-mode .project-card:hover {
      border-color: #555;
      border-left-color: #9999ff;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    }
    body.dark-mode .project-card:hover .project-arrow {
      color: #9999ff;
    }
    body.dark-mode .project-card:focus {
      outline-color: #e0e0e0;
    }
    body.dark-mode .project-card-title {
      color: #e0e0e0;
    }
    body.dark-mode .project-arrow {
      color: #555;
    }
    body.dark-mode .project-thesis {
      border-left-color: #7777bb;
    }
    body.dark-mode .project-thesis-label {
      color: #9999ff;
    }
    body.dark-mode .project-thesis-text {
      color: #888;
    }
    body.dark-mode .project-desc {
      color: #999;
    }
    body.dark-mode .project-tags {
      border-top-color: #333;
    }
    body.dark-mode .project-tag {
      background: #252525;
      color: #888;
    }

    /* ================================
       RESPONSIVE STYLES - Must be last
       ================================ */
    @media (max-width: 1024px) {
      body {
        flex-direction: column;
        height: auto;
        overflow-x: hidden;
        overflow-y: auto;
      }
      .content {
        flex: none;
        order: 2;
        width: 100%;
        overflow: visible;
      }
      .content-inner {
        width: 100%;
        max-width: 100%;
        margin: 0;
        padding: 30px 20px 80px 20px;
        height: auto;
        box-sizing: border-box;
      }
      .content-header {
        position: static;
        background: white;
      }
      body.dark-mode .content-header {
        background: #1a1a1a;
      }
      .tab-content-wrapper {
        position: relative;
        flex: none;
      }
      .tab-content {
        position: relative;
        top: auto;
        left: auto;
        right: auto;
        opacity: 0;
        visibility: hidden;
        height: 0;
        overflow: hidden;
        display: block;
      }
      .tab-content.active {
        opacity: 1;
        visibility: visible;
        height: auto;
        overflow: visible;
      }
      .animation-panel {
        flex: none;
        order: 1;
        min-height: 280px;
        height: 280px;
        position: relative;
        width: 100%;
      }
      .motion-container svg {
        width: 220px;
        height: 220px;
      }
      .conversion-counter {
        bottom: 10px;
        right: 10px;
        font-size: 10px;
      }
    }
    @media (max-width: 768px) {
      .terminal-bar {
        font-size: 10px;
        padding: 6px 12px;
        flex-wrap: wrap;
        gap: 4px;
      }
      .terminal-bar-left, .terminal-bar-right {
        gap: 8px;
      }
      .terminal-bar-right .terminal-segment:last-child {
        display: none;
      }
    }
    @media (max-width: 480px) {
      .terminal-bar {
        font-size: 9px;
        padding: 8px 10px;
        justify-content: center;
      }
      .terminal-bar-left {
        width: 100%;
        justify-content: center;
      }
      .terminal-bar-right {
        display: none;
      }
    }
  </style>
</head>
<body>
  <!-- Terminal status bar -->
  <div class="terminal-bar">
    <div class="terminal-bar-left">
      <div class="terminal-segment">
        <span class="terminal-prompt">$</span>
        <span class="terminal-path">~/robert-laurella</span>
        <span class="terminal-branch">[main]</span>
      </div>
      <div class="terminal-segment">
        <span class="terminal-status">✓ synced</span>
      </div>
    </div>
    <div class="terminal-bar-right">
      <div class="terminal-segment">
        <span class="terminal-time" id="terminal-time"></span>
      </div>
      <div class="terminal-segment terminal-hint-segment">
        <span class="terminal-hint">press <span style="color: #f92672;">/</span> to interact</span>
      </div>
    </div>
  </div>

  <!-- Dark mode toggle -->
  <button class="theme-toggle" id="theme-toggle" aria-label="Toggle dark mode">
    <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
      <path d="M12 18a6 6 0 1 1 0-12 6 6 0 0 1 0 12zm0-2a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM11 1h2v3h-2V1zm0 19h2v3h-2v-3zM3.515 4.929l1.414-1.414L7.05 5.636 5.636 7.05 3.515 4.93zM16.95 18.364l1.414-1.414 2.121 2.121-1.414 1.414-2.121-2.121zm2.121-14.85l1.414 1.415-2.121 2.121-1.414-1.414 2.121-2.121zM5.636 16.95l1.414 1.414-2.121 2.121-1.414-1.414 2.121-2.121zM23 11v2h-3v-2h3zM4 11v2H1v-2h3z"/>
    </svg>
    <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="display: none;">
      <path d="M10 7a7 7 0 0 0 12 4.9v.1c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2h.1A6.979 6.979 0 0 0 10 7zm-6 5a8 8 0 0 0 15.062 3.762A9 9 0 0 1 8.238 4.938 7.999 7.999 0 0 0 4 12z"/>
    </svg>
  </button>

  <div class="content">
    <div class="content-inner">
      <div class="content-header">
        <h1>Robert Laurella</h1>

        <!-- Tab Navigation -->
        <div class="tab-nav">
          <button class="tab-button active" data-tab="home">Home</button>
          <button class="tab-button" data-tab="about">About</button>
          <button class="tab-button" data-tab="projects">Projects</button>
        </div>
      </div>

      <div class="tab-content-wrapper">
        <!-- Home Tab -->
        <div class="tab-content active" id="home-tab">
        <p>Hi! I'm Robert, Director of Product Marketing at <a href=https://botpress.com>Botpress</a>, an artificial intelligence startup.

<br><br>

I hold a PhD in English from the University of Oxford, an MA from the University of Toronto, and a BA (hons.) from McGill University. In my work, I use the skills I developed throughout my academic career to translate complex engineering into thoughtful product marketing initiatives and go-to-market strategies.
</p>

        <div class="social-links">
          <a href="https://www.linkedin.com/in/robertlaurella/" target="_blank" rel="noopener noreferrer" aria-label="LinkedIn">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
              <path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/>
            </svg>
          </a>

          <a href="https://github.com/LaurellaRobert" target="_blank" rel="noopener noreferrer" aria-label="GitHub">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
              <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
            </svg>
          </a>
        </div>

        <div class="github-activity">
          <h2>Recent GitHub Activity</h2>
          <ul class="activity-list" id="github-activity">
            <li class="activity-item">Loading...</li>
          </ul>
        </div>
      </div>

        <!-- About Tab -->
        <div class="tab-content" id="about-tab">
          <div class="terminal-code-wrapper">
            <button class="terminal-code-run" id="run-code-btn"><span class="run-icon">▶</span> run</button>
            <div class="terminal-code"><span class="comment">// robertLaurella.ts</span>
<span class="keyword">interface</span> <span class="type">Skills</span> {
  <span class="property">productMarketing</span>: <span class="type">string</span>[];
  <span class="property">technical</span>: <span class="type">string</span>[];
  <span class="property">interests</span>: <span class="type">string</span>[];
}
<span class="keyword">const</span> <span class="property">robertLaurella</span>: <span class="type">Skills</span> = {

  <span class="property">productMarketing</span>: [
    <span class="string">"Go-to-market strategy"</span>,
    <span class="string">"Product positioning"</span>,
    <span class="string">"Developer relations"</span>,
  ],
  <span class="property">technical</span>: [
    <span class="string">"LLM orchestration & agent workflows"</span>,
    <span class="string">"Web app & live service management"</span>,
    <span class="string">"TypeScript/JavaScript"</span>,
  ],
  <span class="property">interests</span>: [
    <span class="string">"Building good software"</span>,
    <span class="string expandable" data-skill="MMORPGs">"MMORPGs"</span>,
    <span class="string">"Technical storytelling"</span>
  ]
};
<span class="keyword">export default</span> robertLaurella;</div>
          </div>
        </div>

        <!-- Projects Tab -->
        <div class="tab-content" id="projects-tab">
          <div class="projects-header">
            <p>Small apps to test ideas and sharpen implementation.</p>
          </div>
          <div class="projects-grid">

            <a href="https://shouldihaveacupof.coffee/" target="_blank" rel="noopener noreferrer" class="project-card">
              <div class="project-header">
                <h3 class="project-card-title">Should I Have a Cup of Coffee?</h3>
                <span class="project-arrow">→</span>
              </div>
              <div class="project-thesis">
                <div class="project-thesis-label">Thesis</div>
                <p class="project-thesis-text">I wanted to see how far I could push vanilla JavaScript and HTML/CSS animations without having to import additional animation libraries.</p>
              </div>
              <p class="project-desc">A zero-dependency experiment in canvas pixel detection, procedural particle systems, and parallax animation.</p>
              <div class="project-tags">
                <span class="project-tag">LocalStorage</span>
                <span class="project-tag">Canvas API</span>
                <span class="project-tag">CSS Animations</span>
                <span class="project-tag">requestAnimationFrame</span>
                <span class="project-tag">Procedural Animation</span>
                <span class="project-tag">Pixel Manipulation</span>
              </div>
            </a>

          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="animation-panel">
    <div class="conversion-counter" id="conversion-counter">
      <span class="counter-value">0</span> captured
    </div>
    <div class="high-scores-pill" id="high-scores-pill">
      <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path d="M6 9H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h2M18 9h2a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2h-2M6 3h12v7a6 6 0 0 1-12 0V3zM9 21h6M12 16v5" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
      <span class="top-score" id="top-score-display">---</span>
    </div>
    <div class="high-scores-modal" id="high-scores-modal">
      <button class="close-btn" id="close-high-scores">&times;</button>
      <h3>High Scores</h3>
      <ul class="high-scores-list" id="high-scores-list">
        <li><span class="rank">-</span><span class="initials">---</span><span class="score">-</span></li>
      </ul>
    </div>
    <div class="lives-container" id="lives-container">
      <div class="pixel-heart" data-heart="1"></div>
      <div class="pixel-heart" data-heart="2"></div>
      <div class="pixel-heart" data-heart="3"></div>
    </div>
    <div class="shooting-star-alert" id="shooting-star-alert">★ incoming!</div>
    <div class="game-over-overlay" id="game-over-overlay">
      <div class="pixel-skull" id="pixel-skull"></div>
      <div class="game-over-text">Game Over</div>
      <div class="game-over-score">SCORE: <span id="final-score">0</span></div>
      <div class="initials-input-container" id="initials-container">
        <label>New High Score! Enter your initials:</label>
        <input type="text" class="initials-input" id="initials-input" maxlength="3" placeholder="AAA">
        <button class="initials-submit" id="initials-submit">Save</button>
      </div>
      <div class="game-over-leaderboard" id="game-over-leaderboard">
        <h4>Top Scores</h4>
        <ul class="high-scores-list" id="game-over-scores-list">
          <li><span class="rank">-</span><span class="initials">---</span><span class="score">-</span></li>
        </ul>
      </div>
      <div class="game-over-prompt">press <span>/</span> then type <span>clear</span></div>
    </div>
    <canvas id="particle-canvas"></canvas>
    <div class="motion-container">
      <svg viewBox="0 0 400 400" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <!-- Glow filter for tracers -->
          <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
            <feMerge>
              <feMergeNode in="coloredBlur"/>
              <feMergeNode in="coloredBlur"/>
              <feMergeNode in="SourceGraphic"/>
            </feMerge>
          </filter>

          <!-- Stronger glow for the diamond path -->
          <filter id="path-glow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
            <feMerge>
              <feMergeNode in="coloredBlur"/>
              <feMergeNode in="SourceGraphic"/>
            </feMerge>
          </filter>

          <!-- Animated gradient for color cycling -->
          <linearGradient id="rainbow-gradient" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop id="grad-stop-0" offset="0%" style="stop-color:#9999ff;stop-opacity:1" />
            <stop id="grad-stop-1" offset="25%" style="stop-color:#ff99cc;stop-opacity:1" />
            <stop id="grad-stop-2" offset="50%" style="stop-color:#ffcc99;stop-opacity:1" />
            <stop id="grad-stop-3" offset="75%" style="stop-color:#99ffcc;stop-opacity:1" />
            <stop id="grad-stop-4" offset="100%" style="stop-color:#9999ff;stop-opacity:1" />
          </linearGradient>
        </defs>

        <!-- Container for breathing animation -->
        <g id="diamond-group" transform-origin="200 200">
          <!-- Base grey diamond (always visible) -->
          <path
            d="M 200 50 Q 210 140, 320 200 Q 210 260, 200 350 Q 190 260, 80 200 Q 190 140, 200 50 Z"
            stroke="#cccccc"
            stroke-width="3"
            fill="none"
            opacity="0.3"/>

          <!-- Colored diamond that gets revealed -->
          <path id="motion-path"
            d="M 200 50 Q 210 140, 320 200 Q 210 260, 200 350 Q 190 260, 80 200 Q 190 140, 200 50 Z"
            stroke="url(#rainbow-gradient)"
            stroke-width="3"
            fill="none"
            opacity="0.8"
            filter="url(#path-glow)"/>
        </g>

        <!-- Trail container (trails rendered here) -->
        <g id="trail-container"></g>

        <!-- The tracer element -->
        <circle class="tracer" cx="0" cy="0" r="6" fill="#9999ff"/>
      </svg>
    </div>
  </div>

    <script>
      // Fetch GitHub activity
      async function loadGitHubActivity() {
        const GITHUB_TOKEN = '';

        try {
          const headers = {};
          if (GITHUB_TOKEN) {
            headers['Authorization'] = `token ${GITHUB_TOKEN}`;
          }

          const response = await fetch('https://api.github.com/users/LaurellaRobert/events/public?per_page=5', { headers });

          // Check for rate limiting
          if (!response.ok) {
            if (response.status === 403) {
              document.getElementById('github-activity').innerHTML = '<li class="activity-item">GitHub API rate limit reached. Try again later.</li>';
              return;
            }
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const events = await response.json();

          // Build all activity items in memory first
          const activityItems = [];

          for (const event of events.slice(0, 5)) {
            const repoName = event.repo.name.split('/')[1];
            const repoUrl = `https://github.com/${event.repo.name}`;

            let description = '';

            switch(event.type) {
              case 'PushEvent':
                description = `Pushed to <a href="${repoUrl}" target="_blank">${repoName}</a>`;

                // Fetch commit details using the compare API
                if (event.payload.before && event.payload.head) {
                  try {
                    const compareUrl = `https://api.github.com/repos/${event.repo.name}/compare/${event.payload.before}...${event.payload.head}`;
                    const compareResponse = await fetch(compareUrl, { headers });
                    const compareData = await compareResponse.json();

                    if (compareData.commits && compareData.commits.length > 0) {
                      const commitCount = compareData.commits.length;
                      description = `Pushed ${commitCount} commit${commitCount > 1 ? 's' : ''} to <a href="${repoUrl}" target="_blank">${repoName}</a>`;

                      // Show up to 3 commit messages
                      const commits = compareData.commits.slice(0, 3);
                      const commitDetails = commits.map(commit => {
                        const msg = commit.commit.message.split('\n')[0]; // First line only
                        return msg;
                      }).join('<br>');

                      if (commitDetails) {
                        description += `<div class="activity-detail">${commitDetails}</div>`;
                      }
                    }
                  } catch (err) {
                    // If fetching commits fails, just show the basic push message
                    console.warn('Failed to fetch commit details:', err);
                  }
                }
                break;
              case 'CreateEvent':
                description = `Created ${event.payload.ref_type} in <a href="${repoUrl}" target="_blank">${repoName}</a>`;
                break;
              case 'PullRequestEvent':
                if (event.payload.pull_request) {
                  const action = event.payload.action;
                  const prTitle = event.payload.pull_request.title;
                  const prUrl = event.payload.pull_request.html_url;
                  description = `${action.charAt(0).toUpperCase() + action.slice(1)} PR in <a href="${repoUrl}" target="_blank">${repoName}</a>: <a href="${prUrl}" target="_blank">"${prTitle}"</a>`;

                  // Add PR description if available
                  const prBody = event.payload.pull_request.body;
                  if (prBody && prBody.trim().length > 0) {
                    const truncatedBody = prBody.length > 150 ? prBody.substring(0, 150) + '...' : prBody;
                    description += `<div class="activity-detail">${truncatedBody}</div>`;
                  }
                } else {
                  description = `PR activity in <a href="${repoUrl}" target="_blank">${repoName}</a>`;
                }
                break;
              case 'IssuesEvent':
                if (event.payload.issue) {
                  const issueAction = event.payload.action;
                  const issueTitle = event.payload.issue.title;
                  const issueUrl = event.payload.issue.html_url;
                  description = `${issueAction.charAt(0).toUpperCase() + issueAction.slice(1)} issue in <a href="${repoUrl}" target="_blank">${repoName}</a>: <a href="${issueUrl}" target="_blank">"${issueTitle}"</a>`;

                  // Add issue description if available
                  const issueBody = event.payload.issue.body;
                  if (issueBody && issueBody.trim().length > 0) {
                    const truncatedBody = issueBody.length > 150 ? issueBody.substring(0, 150) + '...' : issueBody;
                    description += `<div class="activity-detail">${truncatedBody}</div>`;
                  }
                } else {
                  description = `Issue activity in <a href="${repoUrl}" target="_blank">${repoName}</a>`;
                }
                break;
              case 'WatchEvent':
                description = `Starred <a href="${repoUrl}" target="_blank">${repoName}</a>`;
                break;
              case 'ForkEvent':
                description = `Forked <a href="${repoUrl}" target="_blank">${repoName}</a>`;
                break;
              default:
                description = `Activity in <a href="${repoUrl}" target="_blank">${repoName}</a>`;
            }

            activityItems.push(`<li class="activity-item">${description}</li>`);
          }

          // Update DOM all at once
          const activityList = document.getElementById('github-activity');
          activityList.innerHTML = activityItems.join('');
        } catch (error) {
          console.error('Failed to load GitHub activity:', error);
          document.getElementById('github-activity').innerHTML = '<li class="activity-item">Unable to load activity</li>';
        }
      }

      // Load activity when page loads
      loadGitHubActivity();
    </script>

    <script>
      // Tab switching
      const tabButtons = document.querySelectorAll('.tab-button');
      const tabContents = document.querySelectorAll('.tab-content');

      tabButtons.forEach(button => {
        button.addEventListener('click', () => {
          const targetTab = button.getAttribute('data-tab');

          // Remove active class from all buttons and contents
          tabButtons.forEach(btn => btn.classList.remove('active'));
          tabContents.forEach(content => content.classList.remove('active'));

          // Add active class to clicked button and corresponding content
          button.classList.add('active');
          document.getElementById(`${targetTab}-tab`).classList.add('active');
        });
      });
    </script>

    <script>
      // Run code button - logs robertLaurella to console
      const runCodeBtn = document.getElementById('run-code-btn');

      const robertLaurella = {
        productMarketing: [
          "Go-to-market strategy",
          "Product positioning",
          "Developer relations"
        ],
        technical: [
          "LLM orchestration & agent workflows",
          "Web app & live service management",
          "TypeScript/JavaScript"
        ],
        interests: [
          "Building good software",
          "MMORPGs",
          "Technical storytelling"
        ]
      };

      // Skill descriptions for expandable content
      const skillDescriptions = {
        'MMORPGs': 'I like to play Final Fantasy XIV, World of Warcraft, Maplestory, Lost Ark, Black Desert Online, and Granblue Fantasy.'
      };

      // TypeScript and JavaScript versions of the code
      const typescriptHTML = `<span class="comment">// robertLaurella.ts</span>
<span class="keyword">interface</span> <span class="type">Skills</span> {
  <span class="property">productMarketing</span>: <span class="type">string</span>[];
  <span class="property">technical</span>: <span class="type">string</span>[];
  <span class="property">interests</span>: <span class="type">string</span>[];
}
<span class="keyword">const</span> <span class="property">robertLaurella</span>: <span class="type">Skills</span> = {

  <span class="property">productMarketing</span>: [
    <span class="string">"Go-to-market strategy"</span>,
    <span class="string">"Product positioning"</span>,
    <span class="string">"Developer relations"</span>,
  ],
  <span class="property">technical</span>: [
    <span class="string">"LLM orchestration & agent workflows"</span>,
    <span class="string">"Web app & live service management"</span>,
    <span class="string">"TypeScript/JavaScript"</span>,
  ],
  <span class="property">interests</span>: [
    <span class="string">"Building good software"</span>,
    <span class="string expandable" data-skill="MMORPGs">"MMORPGs"</span>,
    <span class="string">"Technical storytelling"</span>
  ]
};
<span class="keyword">export default</span> robertLaurella;`;

      const javascriptHTML = `<span class="comment">// robertLaurella.js</span>
<span class="keyword">const</span> <span class="property">robertLaurella</span> = {

  <span class="property">productMarketing</span>: [
    <span class="string">"Go-to-market strategy"</span>,
    <span class="string">"Product positioning"</span>,
    <span class="string">"Developer relations"</span>,
  ],
  <span class="property">technical</span>: [
    <span class="string">"LLM orchestration & agent workflows"</span>,
    <span class="string">"Web app & live service management"</span>,
    <span class="string">"TypeScript/JavaScript"</span>,
  ],
  <span class="property">interests</span>: [
    <span class="string">"Building good software"</span>,
    <span class="string expandable" data-skill="MMORPGs">"MMORPGs"</span>,
    <span class="string">"Technical storytelling"</span>
  ]
};
<span class="keyword">export default</span> robertLaurella;`;

      // Track compilation state
      let isCompiled = false;
      let currentView = 'ts'; // 'ts' or 'js'

      // Scramble text animation - characters cycle through random chars before settling
      function scrambleText(element, duration, targetHTML, onComplete) {
        const textContent = element.textContent;
        const scrambleChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789{}[]()<>|/\\!@#$%^&*:;';
        const scrambleColors = ['#9999ff', '#ff99cc', '#ffcc99', '#99ffcc', '#cc99ff', '#99ccff', '#f92672', '#66d9ef', '#a6e22e'];

        // Get target text content for the final result
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = targetHTML;
        const targetText = tempDiv.textContent;

        // Track which characters are "locked" (showing correct char)
        const locked = new Array(targetText.length).fill(false);

        // Pre-lock whitespace characters
        for (let i = 0; i < targetText.length; i++) {
          if (/\s/.test(targetText[i])) locked[i] = true;
        }

        const startTime = Date.now();
        const frameInterval = 40; // ms between frames

        function frame() {
          const elapsed = Date.now() - startTime;
          const progress = Math.min(elapsed / duration, 1);

          // Exponential easing - starts slow, speeds up at the end
          const easedProgress = progress < 0.5
            ? 2 * progress * progress
            : 1 - Math.pow(-2 * progress + 2, 2) / 2;

          // Lock in more characters as time progresses
          const targetLocked = Math.floor(easedProgress * targetText.length);
          let currentLocked = locked.filter(Boolean).length;

          // Randomly lock characters to reach target
          while (currentLocked < targetLocked) {
            const unlocked = [];
            for (let i = 0; i < locked.length; i++) {
              if (!locked[i]) unlocked.push(i);
            }
            if (unlocked.length === 0) break;
            const idx = unlocked[Math.floor(Math.random() * unlocked.length)];
            locked[idx] = true;
            currentLocked++;
          }

          // Build the scrambled string with colors
          let result = '';
          for (let i = 0; i < targetText.length; i++) {
            const char = targetText[i];
            if (/\s/.test(char)) {
              // Preserve whitespace as-is
              result += char;
            } else if (locked[i]) {
              // Locked chars show in a muted color
              result += `<span style="color:#888">${char}</span>`;
            } else {
              // Scrambled chars get random colors
              const randomChar = scrambleChars[Math.floor(Math.random() * scrambleChars.length)];
              const randomColor = scrambleColors[Math.floor(Math.random() * scrambleColors.length)];
              result += `<span style="color:${randomColor}">${randomChar}</span>`;
            }
          }

          element.innerHTML = result;

          if (progress < 1) {
            setTimeout(frame, frameInterval);
          } else {
            // Show target HTML with syntax highlighting
            element.innerHTML = targetHTML;
            if (onComplete) onComplete();
          }
        }

        frame();
      }

      // Create toggle button (hidden initially)
      const toggleBtn = document.createElement('button');
      toggleBtn.className = 'terminal-code-toggle';
      toggleBtn.innerHTML = '<span class="toggle-label">TS</span>';
      toggleBtn.style.display = 'none';
      document.querySelector('.terminal-code-wrapper').appendChild(toggleBtn);

      // Toggle between TS and JS
      toggleBtn.addEventListener('click', () => {
        const codeBlock = document.querySelector('.terminal-code');
        if (currentView === 'js') {
          codeBlock.innerHTML = typescriptHTML;
          currentView = 'ts';
          toggleBtn.innerHTML = '<span class="toggle-label">TS</span>';
          toggleBtn.classList.remove('showing-js');
        } else {
          codeBlock.innerHTML = javascriptHTML;
          currentView = 'js';
          toggleBtn.innerHTML = '<span class="toggle-label">JS</span>';
          toggleBtn.classList.add('showing-js');
        }
        // Re-attach expansion handlers
        attachSkillExpansionHandlers();
      });

      // Handle skill expansion clicks
      function attachSkillExpansionHandlers() {
        const codeBlock = document.querySelector('.terminal-code');
        const expandables = codeBlock.querySelectorAll('.expandable');

        expandables.forEach(el => {
          el.addEventListener('click', (e) => {
            e.stopPropagation();
            const skill = el.getAttribute('data-skill');
            const description = skillDescriptions[skill];
            if (!description) return;

            // Check if already expanded
            const existingExpansion = el.parentElement.querySelector(`.skill-expansion[data-for="${skill}"]`);

            if (existingExpansion) {
              // Collapse
              existingExpansion.classList.remove('visible');
              el.classList.remove('expanded');
              setTimeout(() => existingExpansion.remove(), 300);
            } else {
              // Expand - insert comment line after the skill
              const expansion = document.createElement('span');
              expansion.className = 'skill-expansion';
              expansion.setAttribute('data-for', skill);
              expansion.textContent = `// ${description}`;

              // Insert after the comma following the skill
              el.insertAdjacentElement('afterend', expansion);

              // Trigger animation
              requestAnimationFrame(() => {
                expansion.classList.add('visible');
              });
              el.classList.add('expanded');
            }
          });
        });
      }

      // Attach handlers on initial page load
      attachSkillExpansionHandlers();

      runCodeBtn.addEventListener('click', () => {
        const codeBlock = document.querySelector('.terminal-code');

        // Step 1: Show compiling in terminal
        if (window.showTerminalOutput) {
          window.showTerminalOutput('tsc robertLaurella.ts...', 'success');
        }

        // Visual feedback on button - compiling state
        runCodeBtn.classList.add('ran');
        runCodeBtn.innerHTML = '<span class="run-icon">⟳</span> tsc';

        // Step 2: Run scramble animation, compile TS to JS
        scrambleText(codeBlock, 1200, javascriptHTML, () => {
          // Update state
          isCompiled = true;
          currentView = 'js';

          // Show toggle button
          toggleBtn.style.display = 'flex';
          toggleBtn.innerHTML = '<span class="toggle-label">JS</span>';
          toggleBtn.classList.add('showing-js');

          // Re-attach skill expansion handlers after code change
          attachSkillExpansionHandlers();

          // Delay before showing completion to let users appreciate the animation
          setTimeout(() => {
            // Log compilation steps to console
            console.log('%c> tsc robertLaurella.ts', 'color: #66d9ef; font-size: 12px;');
            console.log('%c✓ compiled to ES2024', 'color: #a6e22e; font-size: 11px;');
            console.log('%c> node robertLaurella.js', 'color: #66d9ef; font-size: 12px;');
            console.log(robertLaurella);

            // Easter egg reveal in console
            console.log('%c\n' +
              '  ╔═════════════════════════════════════════════════════════════════════════════╗\n' +
              '  ║                                                                             ║\n' +
              '  ║    ____        _               _     _                        _ _           ║\n' +
              '  ║   |  _ \\ ___  | |__   ___ _ __| |_  | |    __ _ _   _ _ __ ___| | | __ _    ║\n' +
              '  ║   | |_) / _ \\ | \'_ \\ / _ \\ \'__| __| | |   / _` | | | | \'__/ _ \\ | |/ _` |   ║\n' +
              '  ║   |  _ < (_) || |_) |  __/ |  | |_  | |__| (_| | |_| | | |  __/ | | (_| |   ║\n' +
              '  ║   |_| \\_\\___/ |_.__/ \\___|_|   \\__| |_____\\__,_|\\__,_|_|  \\___|_|_|\\__,_|   ║\n' +
              '  ║                                                                             ║\n' +
              '  ║   You found the easter egg!                                                 ║\n' +
              '  ║                                                                             ║\n' +
              '  ╚═════════════════════════════════════════════════════════════════════════════╝\n',
              'font-family: monospace; color: #9999ff; font-size: 12px; line-height: 1.2;'
            );
            console.log('%cIf you\'re reading this, you\'re probably the kind of person I want to talk to.', 'font-size: 14px; color: #666; font-weight: bold;');
            console.log('%c\n📚 PhD in English → 📈 Product Marketing → 💻 Still shipping code', 'font-size: 13px; color: #999; font-style: italic;');
            console.log('%c\n💬 Let\'s chat: robert.laurella@gmail.com', 'font-size: 13px; color: #333; font-weight: bold;');

            // Update button
            runCodeBtn.innerHTML = '<span class="run-icon">✓</span> ran';

            // Update terminal bar - direct users to browser console (6 seconds visibility)
            if (window.showTerminalOutput) {
              window.showTerminalOutput('✓ open browser console (F12)', 'success', 6000);
            }

            // Reset button after delay
            setTimeout(() => {
              runCodeBtn.classList.remove('ran');
              runCodeBtn.innerHTML = '<span class="run-icon">▶</span> run';
            }, 2000);
          }, 1200);
        });
      });
    </script>


    <script>
      // Terminal status bar - Update time
      function updateTerminalTime() {
        const now = new Date();
        const timeString = now.toLocaleTimeString('en-US', {
          hour: '2-digit',
          minute: '2-digit',
          hour12: false
        });
        document.getElementById('terminal-time').textContent = `${timeString} Montreal`;
      }
      updateTerminalTime();
      setInterval(updateTerminalTime, 1000);
    </script>

    <script>
      // Dark mode toggle
      const themeToggle = document.getElementById('theme-toggle');
      const sunIcon = document.querySelector('.sun-icon');
      const moonIcon = document.querySelector('.moon-icon');

      // Check for saved theme preference or default to light mode
      const currentTheme = localStorage.getItem('theme') || 'light';

      if (currentTheme === 'dark') {
        document.body.classList.add('dark-mode');
        sunIcon.style.display = 'none';
        moonIcon.style.display = 'block';
      }

      // Function to toggle dark mode
      function toggleDarkMode() {
        document.body.classList.toggle('dark-mode');

        if (document.body.classList.contains('dark-mode')) {
          localStorage.setItem('theme', 'dark');
          sunIcon.style.display = 'none';
          moonIcon.style.display = 'block';
        } else {
          localStorage.setItem('theme', 'light');
          sunIcon.style.display = 'block';
          moonIcon.style.display = 'none';
        }
      }

      // Button click handler
      themeToggle.addEventListener('click', toggleDarkMode);

      // Keyboard shortcut: Press 'd' to toggle dark mode
      document.addEventListener('keydown', (e) => {
        // Only trigger if not typing in an input/textarea and terminal not active
        if (e.key === 'd' && !['INPUT', 'TEXTAREA'].includes(e.target.tagName) && !window.terminalActive) {
          toggleDarkMode();
          console.log('🌓 Dark mode toggled via keyboard shortcut');
        }
      });
    </script>

    <!-- Terminal input functionality -->
    <script>
      const terminalBar = document.querySelector('.terminal-bar');
      const terminalBarLeft = document.querySelector('.terminal-bar-left');
      const terminalBarRight = document.querySelector('.terminal-bar-right');

      let originalLeftContent = terminalBarLeft.innerHTML;
      let originalRightContent = terminalBarRight.innerHTML;
      window.terminalActive = false;
      let outputTimeout = null;

      // Command definitions
      const commands = {
        help: () => ({
          text: 'ls · home · about · projects · theme · whoami · contact · hire · run · coffee · clear · reset',
          type: 'success'
        }),
        ls: () => ({
          text: 'home  about  projects',
          type: 'success'
        }),
        home: () => {
          document.querySelector('[data-tab="home"]').click();
          return { text: '→ home', type: 'success' };
        },
        about: () => {
          document.querySelector('[data-tab="about"]').click();
          return { text: '→ about', type: 'success' };
        },
        projects: () => {
          document.querySelector('[data-tab="projects"]').click();
          return { text: '→ projects', type: 'success' };
        },
        cd: (args) => {
          const tab = args[0]?.toLowerCase();
          const validTabs = ['home', 'about', 'projects'];
          if (!tab) {
            return { text: 'usage: cd <tab>', type: 'error' };
          }
          if (validTabs.includes(tab)) {
            document.querySelector(`[data-tab="${tab}"]`).click();
            return { text: `→ ${tab}`, type: 'success' };
          }
          return { text: `cd: ${tab}: no such tab`, type: 'error' };
        },
        theme: (args) => {
          const mode = args[0]?.toLowerCase();
          if (mode === 'dark') {
            document.body.classList.add('dark-mode');
            localStorage.setItem('theme', 'dark');
            document.querySelector('.sun-icon').style.display = 'none';
            document.querySelector('.moon-icon').style.display = 'block';
            return { text: 'theme → dark', type: 'success' };
          } else if (mode === 'light') {
            document.body.classList.remove('dark-mode');
            localStorage.setItem('theme', 'light');
            document.querySelector('.sun-icon').style.display = 'block';
            document.querySelector('.moon-icon').style.display = 'none';
            return { text: 'theme → light', type: 'success' };
          } else {
            // Toggle
            document.getElementById('theme-toggle').click();
            const isDark = document.body.classList.contains('dark-mode');
            return { text: `theme → ${isDark ? 'dark' : 'light'}`, type: 'success' };
          }
        },
        whoami: () => ({
          text: 'PhD → Product Marketing → still ships code',
          type: 'success'
        }),
        contact: () => {
          navigator.clipboard.writeText('robert.laurella@gmail.com');
          return { text: 'robert.laurella@gmail.com — copied', type: 'success' };
        },
        email: () => commands.contact(),
        hire: () => {
          navigator.clipboard.writeText('robert.laurella@gmail.com');
          return { text: "let's talk → robert.laurella@gmail.com — copied", type: 'success' };
        },
        coffee: () => {
          window.open('https://shouldihaveacupof.coffee/', '_blank');
          return { text: '☕ opening...', type: 'success' };
        },
        clear: () => {
          // Reset particles, game state, and demo
          if (window.initParticles) {
            window.initParticles();
          }
          localStorage.removeItem('particle-demo-seen');
          // Trigger the demo again after a short delay
          setTimeout(() => {
            if (window.triggerAutoDemo) {
              window.triggerAutoDemo();
            }
          }, 500);
          return { text: 'game reset — good luck!', type: 'success' };
        },
        reset: () => {
          // Alias for clear
          return commands.clear();
        },
        sudo: () => ({
          text: 'nice try',
          type: 'error'
        }),
        run: () => {
          // Trigger the run button click
          document.getElementById('run-code-btn').click();
          return { text: 'executed → check console', type: 'success' };
        }
      };

      function activateTerminal() {
        if (window.terminalActive) return;
        window.terminalActive = true;

        if (outputTimeout) {
          clearTimeout(outputTimeout);
          outputTimeout = null;
        }

        terminalBar.classList.add('input-mode');
        terminalBarLeft.innerHTML = `
          <div class="terminal-segment">
            <span class="terminal-prompt">$</span>
            <input type="text" class="terminal-input" placeholder="type a command..." autofocus>
          </div>
        `;
        terminalBarRight.innerHTML = `
          <div class="terminal-segment">
            <span class="terminal-hint">enter to run · esc to close</span>
          </div>
        `;

        const input = terminalBar.querySelector('.terminal-input');
        input.focus();

        input.addEventListener('keydown', handleTerminalInput);
        input.addEventListener('blur', handleTerminalBlur);
      }

      function handleTerminalInput(e) {
        if (e.key === 'Enter') {
          const input = e.target;
          const value = input.value.trim();

          if (value) {
            executeCommand(value);
          } else {
            deactivateTerminal();
          }
        } else if (e.key === 'Escape') {
          deactivateTerminal();
        }
      }

      function handleTerminalBlur(e) {
        // Small delay to allow clicking within terminal
        setTimeout(() => {
          if (window.terminalActive && !terminalBar.contains(document.activeElement)) {
            deactivateTerminal();
          }
        }, 100);
      }

      function executeCommand(input) {
        const parts = input.split(/\s+/);
        const cmd = parts[0].toLowerCase();
        const args = parts.slice(1);

        let result;
        if (commands[cmd]) {
          result = commands[cmd](args);
        } else {
          result = { text: `command not found: ${cmd}`, type: 'error' };
        }

        showOutput(result.text, result.type);
      }

      function showOutput(text, type = 'success', duration = 3000) {
        window.terminalActive = false;
        terminalBar.classList.remove('input-mode');

        terminalBarLeft.innerHTML = `
          <div class="terminal-segment">
            <span class="terminal-prompt">$</span>
            <span class="terminal-output ${type}">${text}</span>
          </div>
        `;
        terminalBarRight.innerHTML = originalRightContent;

        // Clear any existing timeout before setting new one
        if (outputTimeout) {
          clearTimeout(outputTimeout);
        }

        // Return to normal after delay
        outputTimeout = setTimeout(() => {
          deactivateTerminal();
        }, duration);
      }

      // Expose for external use (e.g., run button)
      window.showTerminalOutput = showOutput;

      function deactivateTerminal() {
        window.terminalActive = false;
        terminalBar.classList.remove('input-mode');
        terminalBarLeft.innerHTML = originalLeftContent;
        terminalBarRight.innerHTML = originalRightContent;

        if (outputTimeout) {
          clearTimeout(outputTimeout);
          outputTimeout = null;
        }
      }

      // Activate on '/' key
      document.addEventListener('keydown', (e) => {
        if (e.key === '/' && !['INPUT', 'TEXTAREA'].includes(e.target.tagName)) {
          e.preventDefault();
          activateTerminal();
        }
      });

      // Activate on click
      terminalBar.addEventListener('click', (e) => {
        if (!window.terminalActive) {
          activateTerminal();
        }
      });
    </script>

    <!-- Anime.js v4 -->
    <script type="module">
      import { animate, svg, utils, createTimer } from 'https://cdn.jsdelivr.net/npm/animejs@4.3.5/+esm';

      // Get the path length
      const path = document.querySelector('#motion-path');
      const pathLength = path.getTotalLength();
      const svgElement = document.querySelector('.motion-container svg');
      const animationPanel = document.querySelector('.animation-panel');
      const trailContainer = document.querySelector('#trail-container');
      const mainTracer = document.querySelector('.tracer');

      // Set up stroke-dasharray and initial dashoffset
      path.style.strokeDasharray = pathLength;
      path.style.strokeDashoffset = pathLength;

      // ========================================
      // 1. COLOR CYCLING - Slow gradient shift
      // ========================================
      const gradientColors = [
        ['#9999ff', '#ff99cc', '#ffcc99', '#99ffcc', '#9999ff'],
        ['#ff99cc', '#ffcc99', '#99ffcc', '#9999ff', '#ff99cc'],
        ['#ffcc99', '#99ffcc', '#9999ff', '#ff99cc', '#ffcc99'],
        ['#99ffcc', '#9999ff', '#ff99cc', '#ffcc99', '#99ffcc'],
      ];

      let colorPhase = 0;
      function cycleColors() {
        const stops = document.querySelectorAll('[id^="grad-stop-"]');
        const currentColors = gradientColors[Math.floor(colorPhase) % gradientColors.length];
        const nextColors = gradientColors[Math.floor(colorPhase + 1) % gradientColors.length];
        const blend = colorPhase % 1;

        stops.forEach((stop, i) => {
          const current = currentColors[i];
          const next = nextColors[i];
          // Simple color interpolation
          const blended = blendColors(current, next, blend);
          stop.style.stopColor = blended;
        });

        colorPhase += 0.002; // Slow cycle
        requestAnimationFrame(cycleColors);
      }

      function blendColors(c1, c2, t) {
        const r1 = parseInt(c1.slice(1, 3), 16);
        const g1 = parseInt(c1.slice(3, 5), 16);
        const b1 = parseInt(c1.slice(5, 7), 16);
        const r2 = parseInt(c2.slice(1, 3), 16);
        const g2 = parseInt(c2.slice(3, 5), 16);
        const b2 = parseInt(c2.slice(5, 7), 16);
        const r = Math.round(r1 + (r2 - r1) * t);
        const g = Math.round(g1 + (g2 - g1) * t);
        const b = Math.round(b1 + (b2 - b1) * t);
        return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
      }

      cycleColors();

      // ========================================
      // 2. BREATHING - Subtle scale pulse
      // ========================================
      animate('#diamond-group', {
        scale: [1, 1.02, 1],
        duration: 4000,
        ease: 'easeInOutSine',
        loop: true
      });

      // ========================================
      // 3. TRACER TRAILS - Fading comet tails
      // ========================================
      const trails = [];
      const maxTrailLength = 12;
      const trailInterval = 50; // ms between trail dots

      function createTrailDot(x, y, color, size = 4) {
        const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        dot.setAttribute('cx', x);
        dot.setAttribute('cy', y);
        dot.setAttribute('r', size);
        dot.setAttribute('fill', color);
        dot.setAttribute('opacity', '0.6');
        trailContainer.appendChild(dot);
        return dot;
      }

      // Trail system for main tracer
      let lastTrailTime = 0;
      const mainTrail = [];

      function updateMainTrail() {
        const now = Date.now();
        if (now - lastTrailTime > trailInterval) {
          const transform = mainTracer.getAttribute('transform');
          if (transform) {
            const match = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
            if (match) {
              const x = parseFloat(match[1]);
              const y = parseFloat(match[2]);
              const dot = createTrailDot(x, y, '#9999ff', 4);
              mainTrail.push({ element: dot, opacity: 0.6 });

              // Limit trail length
              if (mainTrail.length > maxTrailLength) {
                const old = mainTrail.shift();
                old.element.remove();
              }
            }
          }
          lastTrailTime = now;
        }

        // Fade out trail dots
        mainTrail.forEach((dot, i) => {
          const targetOpacity = (i / mainTrail.length) * 0.5;
          dot.element.setAttribute('opacity', targetOpacity);
          const scale = 0.3 + (i / mainTrail.length) * 0.7;
          dot.element.setAttribute('r', 4 * scale);
        });

        requestAnimationFrame(updateMainTrail);
      }

      updateMainTrail();

      // ========================================
      // ADDITIONAL TRACERS with trails
      // ========================================
      const additionalTracers = [];
      const maxTracers = 10;
      const tracerColors = ['#9999ff', '#ff99cc', '#ffcc99', '#99ffcc', '#cc99ff', '#99ccff'];

      function createTracer(delay = 0) {
        const color = tracerColors[Math.floor(Math.random() * tracerColors.length)];
        const tracer = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        tracer.setAttribute('class', 'additional-tracer');
        tracer.setAttribute('r', 5);
        tracer.setAttribute('fill', color);
        tracer.setAttribute('opacity', 0.9);
        svgElement.appendChild(tracer);

        const tracerTrail = [];
        let tracerLastTrailTime = 0;

        // Trail update for this tracer
        const trailUpdater = () => {
          const now = Date.now();
          if (now - tracerLastTrailTime > trailInterval) {
            const transform = tracer.getAttribute('transform');
            if (transform) {
              const match = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
              if (match) {
                const x = parseFloat(match[1]);
                const y = parseFloat(match[2]);
                const dot = createTrailDot(x, y, color, 3);
                tracerTrail.push({ element: dot, opacity: 0.5 });

                if (tracerTrail.length > 8) {
                  const old = tracerTrail.shift();
                  old.element.remove();
                }
              }
            }
            tracerLastTrailTime = now;
          }

          // Fade trail
          tracerTrail.forEach((dot, i) => {
            const targetOpacity = (i / tracerTrail.length) * 0.4;
            dot.element.setAttribute('opacity', targetOpacity);
            const scale = 0.3 + (i / tracerTrail.length) * 0.7;
            dot.element.setAttribute('r', 3 * scale);
          });
        };

        const animation = animate(tracer, {
          ease: 'linear',
          duration: 8000,
          loop: true,
          delay: delay,
          ...svg.createMotionPath('#motion-path')
        });

        const trailIntervalId = setInterval(trailUpdater, 16);

        additionalTracers.push({
          element: tracer,
          animation: animation,
          color: color,
          trail: tracerTrail,
          trailIntervalId: trailIntervalId,
          createdAt: Date.now()
        });

        // Auto-remove after 15 seconds
        setTimeout(() => {
          const index = additionalTracers.findIndex(t => t.element === tracer);
          if (index !== -1) {
            const t = additionalTracers[index];
            clearInterval(t.trailIntervalId);
            t.animation.pause();
            t.trail.forEach(dot => dot.element.remove());
            tracer.remove();
            additionalTracers.splice(index, 1);
          }
        }, 15000);
      }

      // Expose createTracer for particle-to-tracer conversion
      window.createDiamondTracer = createTracer;

      // Click to add tracers
      animationPanel.addEventListener('click', (e) => {
        if (additionalTracers.length < maxTracers) {
          createTracer(0);
          console.log('✨ Tracer spawned! Click to add more (max 10)');
        } else {
          console.log('⚠️ Max tracers reached (10)');
        }
      });

      // Animate main tracer along the motion path
      animate('.tracer', {
        ease: 'linear',
        duration: 8000,
        loop: true,
        ...svg.createMotionPath('#motion-path')
      });

      // Create reveal and erase effect
      animate('#motion-path', {
        strokeDashoffset: [
          { to: 0, duration: 8000, ease: 'linear' },
          { to: -pathLength, duration: 8000, ease: 'linear' }
        ],
        loop: true
      });
    </script>

    <script>
      // Particle Network Animation
      const canvas = document.getElementById('particle-canvas');
      const ctx = canvas.getContext('2d');
      const particlePanel = document.querySelector('.animation-panel');
      const diamondPath = document.querySelector('#motion-path');
      const svg = document.querySelector('.motion-container svg');

      let particles = [];
      let mouse = { x: null, y: null, radius: 150 };

      // Get SVG viewBox dimensions for coordinate conversion
      const viewBox = svg.viewBox.baseVal;
      const svgWidth = viewBox.width;
      const svgHeight = viewBox.height;

      // Resize canvas
      function resizeCanvas() {
        canvas.width = particlePanel.offsetWidth;
        canvas.height = particlePanel.offsetHeight;
      }
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);

      // Particle colors matching gradient
      const colors = ['#9999ff', '#ff99cc', '#ffcc99', '#99ffcc', '#cc99ff', '#99ccff'];

      // Conversion counter
      let conversionCount = 0;
      const counterElement = document.getElementById('conversion-counter');
      const counterValue = counterElement.querySelector('.counter-value');

      function updateConversionCounter() {
        conversionCount++;
        counterValue.textContent = conversionCount;

        // Pulse animation on update
        counterElement.classList.remove('pulse');
        void counterElement.offsetWidth; // Trigger reflow
        counterElement.classList.add('pulse');

        // Remove attention animation after first capture
        counterElement.classList.remove('attention');
      }

      // Start with attention-grabbing pulse if counter is at 0
      counterElement.classList.add('attention');

      // Conversion effect particles
      let conversionEffects = [];

      class ConversionEffect {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.particles = [];

          // Create burst particles
          for (let i = 0; i < 12; i++) {
            const angle = (Math.PI * 2 * i) / 12;
            this.particles.push({
              x: x,
              y: y,
              vx: Math.cos(angle) * 3,
              vy: Math.sin(angle) * 3,
              life: 1.0,
              color: colors[Math.floor(Math.random() * colors.length)]
            });
          }
        }

        update() {
          this.particles.forEach(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.vx *= 0.95;
            p.vy *= 0.95;
            p.life -= 0.05;
          });
          return this.particles.some(p => p.life > 0);
        }

        draw() {
          this.particles.forEach(p => {
            if (p.life > 0) {
              ctx.beginPath();
              ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
              ctx.fillStyle = p.color.replace(')', `, ${p.life})`).replace('rgb', 'rgba');
              ctx.fill();
            }
          });
        }
      }

      // Special starburst effect for shooting star captures
      class StarburstEffect {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.life = 1.0;

          // Expanding rings
          this.rings = [
            { radius: 0, maxRadius: 80, speed: 4, width: 3, opacity: 1 },
            { radius: 0, maxRadius: 60, speed: 3, width: 2, opacity: 0.8, delay: 5 },
            { radius: 0, maxRadius: 100, speed: 5, width: 1, opacity: 0.6, delay: 10 }
          ];
          this.ringFrame = 0;

          // Starburst particles - more dramatic
          this.particles = [];
          const starColors = ['#ffcc00', '#fff8dc', '#ffd700', '#ffaa00', '#ffffff'];

          // Create starburst rays
          for (let i = 0; i < 16; i++) {
            const angle = (Math.PI * 2 * i) / 16;
            const speed = 4 + Math.random() * 3;
            this.particles.push({
              x: x,
              y: y,
              vx: Math.cos(angle) * speed,
              vy: Math.sin(angle) * speed,
              life: 1.0,
              color: starColors[Math.floor(Math.random() * starColors.length)],
              size: 2 + Math.random() * 2,
              isStar: i % 4 === 0 // Every 4th particle is a mini star
            });
          }

          // Add some random sparkles
          for (let i = 0; i < 20; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 1 + Math.random() * 5;
            this.particles.push({
              x: x,
              y: y,
              vx: Math.cos(angle) * speed,
              vy: Math.sin(angle) * speed,
              life: 1.0,
              color: starColors[Math.floor(Math.random() * starColors.length)],
              size: 1 + Math.random(),
              isStar: false
            });
          }
        }

        // Draw mini star shape
        drawMiniStar(cx, cy, size) {
          ctx.beginPath();
          for (let i = 0; i < 10; i++) {
            const radius = i % 2 === 0 ? size : size * 0.4;
            const angle = (i * Math.PI / 5) - Math.PI / 2;
            const x = cx + Math.cos(angle) * radius;
            const y = cy + Math.sin(angle) * radius;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.closePath();
        }

        update() {
          this.ringFrame++;
          this.life -= 0.02;

          // Update particles
          this.particles.forEach(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.vx *= 0.96;
            p.vy *= 0.96;
            p.life -= 0.03;
          });

          // Update rings
          this.rings.forEach(ring => {
            if (this.ringFrame > (ring.delay || 0)) {
              ring.radius += ring.speed;
              ring.opacity = Math.max(0, 1 - ring.radius / ring.maxRadius);
            }
          });

          return this.life > 0;
        }

        draw() {
          // Draw expanding rings
          this.rings.forEach(ring => {
            if (ring.opacity > 0) {
              ctx.beginPath();
              ctx.arc(this.x, this.y, ring.radius, 0, Math.PI * 2);
              ctx.strokeStyle = `rgba(255, 204, 0, ${ring.opacity * 0.7})`;
              ctx.lineWidth = ring.width;
              ctx.stroke();
            }
          });

          // Draw particles
          this.particles.forEach(p => {
            if (p.life > 0) {
              ctx.globalAlpha = p.life;

              if (p.isStar) {
                // Draw as mini star
                ctx.fillStyle = p.color;
                this.drawMiniStar(p.x, p.y, p.size * 2);
                ctx.fill();
              } else {
                // Draw as glowing circle
                ctx.shadowColor = p.color;
                ctx.shadowBlur = 5;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fillStyle = p.color;
                ctx.fill();
                ctx.shadowBlur = 0;
              }

              ctx.globalAlpha = 1;
            }
          });

          // Central flash (fades quickly)
          if (this.life > 0.7) {
            const flashIntensity = (this.life - 0.7) / 0.3;
            ctx.beginPath();
            ctx.arc(this.x, this.y, 15 * flashIntensity, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 255, 255, ${flashIntensity * 0.8})`;
            ctx.fill();
          }

          // Reset canvas state
          ctx.globalAlpha = 1;
          ctx.shadowBlur = 0;
          ctx.lineWidth = 1;
        }
      }

      // Track starburst effects separately
      let starburstEffects = [];

      // Particle class
      class Particle {
        constructor(autoPilot = false) {
          this.x = Math.random() * canvas.width;
          this.y = Math.random() * canvas.height;
          this.vx = (Math.random() - 0.5) * 0.5;
          this.vy = (Math.random() - 0.5) * 0.5;
          this.radius = Math.random() * 2 + 1;
          this.color = colors[Math.floor(Math.random() * colors.length)];
          this.locked = false;
          this.autoPilot = autoPilot;
        }

        update() {
          let shouldConvert = false;

          // Auto-pilot mode: steer toward diamond center
          if (this.autoPilot) {
            // Get diamond center in canvas coordinates
            const svgRect = svg.getBoundingClientRect();
            const canvasRect = canvas.getBoundingClientRect();
            const targetX = (svgRect.left - canvasRect.left) + (svgRect.width / 2);
            const targetY = (svgRect.top - canvasRect.top) + (svgRect.height / 2);

            const dx = targetX - this.x;
            const dy = targetY - this.y;
            const angle = Math.atan2(dy, dx);

            // Gentle acceleration toward center
            this.vx += Math.cos(angle) * 0.08;
            this.vy += Math.sin(angle) * 0.08;
          }
          // Mouse interaction
          else if (mouse.x !== null && mouse.y !== null) {
            const dx = mouse.x - this.x;
            const dy = mouse.y - this.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < mouse.radius || this.locked) {
              this.locked = true; // Lock particle to cursor

              // Always attract locked particles toward cursor
              const angle = Math.atan2(dy, dx);
              const attractionStrength = 0.15;
              this.vx += Math.cos(angle) * attractionStrength;
              this.vy += Math.sin(angle) * attractionStrength;
            }
          } else {
            // Mouse left - unlock particle
            this.locked = false;
          }

          // Store old position
          const oldX = this.x;
          const oldY = this.y;

          // Move particle
          this.x += this.vx;
          this.y += this.vy;

          // Check collision with diamond
          const { x: svgX, y: svgY } = this.canvasToSvg();

          if (this.isInsideDiamond(svgX, svgY)) {
            // Particle has entered the diamond!
            if (this.locked || this.autoPilot) {
              // Being dragged or auto-piloted - convert to tracer
              shouldConvert = true;
            } else {
              // Not being dragged - bounce back
              this.x = oldX;
              this.y = oldY;
              this.bounceOffDiamond();
            }
          } else if (this.isAtDiamondEdge(svgX, svgY) && (this.locked || this.autoPilot)) {
            // At the edge and being dragged/piloted - convert
            shouldConvert = true;
          }

          // Damping
          this.vx *= 0.98;
          this.vy *= 0.98;

          // Bounce off edges
          if (this.x < 0 || this.x > canvas.width) this.vx *= -1;
          if (this.y < 0 || this.y > canvas.height) this.vy *= -1;

          // Keep in bounds
          this.x = Math.max(0, Math.min(canvas.width, this.x));
          this.y = Math.max(0, Math.min(canvas.height, this.y));

          return shouldConvert;
        }

        // Convert canvas coords to SVG coords
        canvasToSvg() {
          const svgRect = svg.getBoundingClientRect();
          const canvasRect = canvas.getBoundingClientRect();
          const relativeX = this.x + canvasRect.left - svgRect.left;
          const relativeY = this.y + canvasRect.top - svgRect.top;
          const svgX = (relativeX / svgRect.width) * svgWidth;
          const svgY = (relativeY / svgRect.height) * svgHeight;
          return { x: svgX, y: svgY };
        }

        // Check if point is inside the diamond (rhombus)
        // Diamond vertices: top (200,50), right (320,200), bottom (200,350), left (80,200)
        // For rhombus: |x - cx| / halfWidth + |y - cy| / halfHeight <= 1
        isInsideDiamond(svgX, svgY) {
          const centerX = 200;
          const centerY = 200;
          const halfWidth = 120;  // right vertex is at 320, so 320 - 200 = 120
          const halfHeight = 150; // top vertex is at 50, so 200 - 50 = 150

          // Rhombus equation: normalized manhattan distance
          const normalizedDist = Math.abs(svgX - centerX) / halfWidth + Math.abs(svgY - centerY) / halfHeight;
          return normalizedDist <= 1;
        }

        // Check if particle is at the diamond boundary (for conversion)
        isAtDiamondEdge(svgX, svgY) {
          const centerX = 200;
          const centerY = 200;
          const halfWidth = 120;
          const halfHeight = 150;

          const normalizedDist = Math.abs(svgX - centerX) / halfWidth + Math.abs(svgY - centerY) / halfHeight;
          // At edge means within a small tolerance of the boundary (value = 1)
          return normalizedDist > 0.85 && normalizedDist <= 1.05;
        }

        isNearDiamond() {
          const { x: svgX, y: svgY } = this.canvasToSvg();
          return this.isAtDiamondEdge(svgX, svgY);
        }

        // Bounce particle off the diamond edge
        bounceOffDiamond() {
          const { x: svgX, y: svgY } = this.canvasToSvg();
          const centerX = 200;
          const centerY = 200;

          // Calculate normal direction (pointing outward from center)
          const dx = svgX - centerX;
          const dy = svgY - centerY;
          const len = Math.sqrt(dx * dx + dy * dy);
          const nx = dx / len;
          const ny = dy / len;

          // Reflect velocity: v' = v - 2(v·n)n
          const dot = this.vx * nx + this.vy * ny;
          this.vx = this.vx - 2 * dot * nx;
          this.vy = this.vy - 2 * dot * ny;

          // Add some outward push
          this.vx += nx * 0.5;
          this.vy += ny * 0.5;
        }

        draw() {
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fillStyle = this.color;
          ctx.fill();
        }
      }

      // Target particle count
      function getTargetParticleCount() {
        return Math.floor((canvas.width * canvas.height) / 15000);
      }

      // Initialize particles
      function initParticles() {
        particles = [];
        const particleCount = getTargetParticleCount();
        for (let i = 0; i < particleCount; i++) {
          particles.push(new Particle());
        }
      }
      initParticles();
      window.initParticles = initParticles; // Expose for terminal command

      // One-time auto-demo for first-time visitors
      function triggerAutoDemo() {
        const hasSeenDemo = localStorage.getItem('particle-demo-seen');
        if (hasSeenDemo) return;

        // Wait a few seconds, then launch an auto-pilot particle
        setTimeout(() => {
          const demoParticle = new Particle(true);
          // Start from a corner for dramatic effect
          demoParticle.x = canvas.width * 0.15;
          demoParticle.y = canvas.height * 0.85;
          demoParticle.radius = 3;
          demoParticle.color = '#9999ff';
          particles.push(demoParticle);

          // Mark demo as seen
          localStorage.setItem('particle-demo-seen', 'true');
        }, 3000);
      }
      triggerAutoDemo();
      window.triggerAutoDemo = triggerAutoDemo; // Expose for terminal command

      // Respawn particles from edges
      function spawnParticleFromEdge() {
        const particle = new Particle();
        // Spawn from a random edge
        const edge = Math.floor(Math.random() * 4);
        switch (edge) {
          case 0: // Top
            particle.x = Math.random() * canvas.width;
            particle.y = 0;
            particle.vy = Math.random() * 0.5 + 0.2;
            break;
          case 1: // Right
            particle.x = canvas.width;
            particle.y = Math.random() * canvas.height;
            particle.vx = -(Math.random() * 0.5 + 0.2);
            break;
          case 2: // Bottom
            particle.x = Math.random() * canvas.width;
            particle.y = canvas.height;
            particle.vy = -(Math.random() * 0.5 + 0.2);
            break;
          case 3: // Left
            particle.x = 0;
            particle.y = Math.random() * canvas.height;
            particle.vx = Math.random() * 0.5 + 0.2;
            break;
        }
        return particle;
      }

      // Respawn timing
      let lastRespawnTime = 0;
      const respawnInterval = 225; // ms between respawns (25% faster)

      // Connect particles
      function connectParticles() {
        for (let i = 0; i < particles.length; i++) {
          for (let j = i + 1; j < particles.length; j++) {
            const dx = particles[i].x - particles[j].x;
            const dy = particles[i].y - particles[j].y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < 120) {
              const opacity = 1 - (distance / 120);
              ctx.strokeStyle = `rgba(153, 153, 255, ${opacity * 0.3})`;
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(particles[i].x, particles[i].y);
              ctx.lineTo(particles[j].x, particles[j].y);
              ctx.stroke();
            }
          }

          // Connect to mouse
          if (mouse.x !== null && mouse.y !== null) {
            const dx = particles[i].x - mouse.x;
            const dy = particles[i].y - mouse.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // Show connection if within radius OR if particle is locked
            if (distance < mouse.radius || particles[i].locked) {
              const opacity = particles[i].locked ? 0.7 : (1 - (distance / mouse.radius)) * 0.5;
              ctx.strokeStyle = `rgba(153, 153, 255, ${opacity})`;
              ctx.lineWidth = particles[i].locked ? 2.5 : 2;
              ctx.beginPath();
              ctx.moveTo(particles[i].x, particles[i].y);
              ctx.lineTo(mouse.x, mouse.y);
              ctx.stroke();
            }
          }
        }
      }

      // Animation loop (shooting stars integrated below)
      let animationStarted = false;
      function animate() {
        if (animationStarted) return; // Prevent double-start
      }
      // Don't auto-start - will be started by shooting star code below

      // Mouse move event
      particlePanel.addEventListener('mousemove', (e) => {
        const rect = particlePanel.getBoundingClientRect();
        mouse.x = e.clientX - rect.left;
        mouse.y = e.clientY - rect.top;
      });

      particlePanel.addEventListener('mouseleave', () => {
        mouse.x = null;
        mouse.y = null;
      });

      // Reinitialize on resize
      window.addEventListener('resize', () => {
        resizeCanvas();
        initParticles();
      });

      // ========================================
      // SHOOTING STAR GAME MECHANICS
      // ========================================

      // Lives system
      let lives = 3;
      const heartsContainer = document.getElementById('lives-container');
      const shootingStarAlert = document.getElementById('shooting-star-alert');

      // Game state
      let gameOver = false;
      const gameOverOverlay = document.getElementById('game-over-overlay');
      const finalScoreElement = document.getElementById('final-score');
      const pixelSkull = document.getElementById('pixel-skull');

      // Screen flash effect (drawn in animation loop)
      let screenFlash = { active: false, alpha: 0, color: 'rgba(255, 68, 68,' };

      function triggerScreenFlash(color = 'rgba(255, 68, 68,') {
        screenFlash.active = true;
        screenFlash.alpha = 0.3;
        screenFlash.color = color;
      }

      function loseLife() {
        if (lives <= 0 || gameOver) return;

        lives--;
        const heart = heartsContainer.querySelector(`[data-heart="${lives + 1}"]`);
        if (heart) {
          heart.classList.add('losing');
          setTimeout(() => {
            heart.classList.remove('losing');
            heart.classList.add('lost');
          }, 500);
        }

        // Trigger screen flash (will be drawn in animation loop)
        triggerScreenFlash();

        if (lives <= 0) {
          triggerGameOver();
        }
      }

      function triggerGameOver() {
        gameOver = true;

        // Update final score
        finalScoreElement.textContent = conversionCount;

        // Show game over screen with slight delay for dramatic effect
        setTimeout(() => {
          gameOverOverlay.classList.add('visible');
          pixelSkull.classList.add('animate');

          // Check if score qualifies for high score entry
          if (window.checkHighScore) {
            window.checkHighScore(conversionCount);
          }

          // Show terminal hint in the terminal bar
          if (window.showTerminalOutput) {
            window.showTerminalOutput('game over — type "clear" to restart', 'error', 10000);
          }
        }, 600);

        console.log('💔 Game over! Final score:', conversionCount);
        console.log('💡 Use the terminal: press / and type "clear" to restart');
      }

      function resetLives() {
        lives = 3;
        gameOver = false;
        const hearts = heartsContainer.querySelectorAll('.pixel-heart');
        hearts.forEach(heart => {
          heart.classList.remove('lost', 'losing');
        });

        // Hide game over screen
        gameOverOverlay.classList.remove('visible');
        pixelSkull.classList.remove('animate');

        // Reset high score input
        if (window.resetHighScoreInput) {
          window.resetHighScoreInput();
        }
      }

      // Expose for terminal clear command
      const originalInitParticles = window.initParticles;
      window.initParticles = function() {
        originalInitParticles();
        resetLives();
        shootingStars = [];
        starburstEffects = [];
        conversionCount = 0;
        counterValue.textContent = '0';
      };

      // Shooting Star class
      class ShootingStar {
        constructor() {
          // Random starting edge
          const edge = Math.floor(Math.random() * 4);
          const speed = 2 + Math.random() * 2; // Faster than normal particles

          switch (edge) {
            case 0: // Top
              this.x = Math.random() * canvas.width;
              this.y = -10;
              this.vx = (Math.random() - 0.5) * 2;
              this.vy = speed;
              break;
            case 1: // Right
              this.x = canvas.width + 10;
              this.y = Math.random() * canvas.height;
              this.vx = -speed;
              this.vy = (Math.random() - 0.5) * 2;
              break;
            case 2: // Bottom
              this.x = Math.random() * canvas.width;
              this.y = canvas.height + 10;
              this.vx = (Math.random() - 0.5) * 2;
              this.vy = -speed;
              break;
            case 3: // Left
              this.x = -10;
              this.y = Math.random() * canvas.height;
              this.vx = speed;
              this.vy = (Math.random() - 0.5) * 2;
              break;
          }

          this.radius = 4;
          this.color = '#ffcc00'; // Golden yellow
          this.trail = [];
          this.maxTrailLength = 15;
          this.locked = false;
          this.lifetime = 0;
          this.maxLifetime = 300; // ~5 seconds at 60fps
        }

        // Reuse particle's coordinate conversion
        canvasToSvg() {
          const svgRect = svg.getBoundingClientRect();
          const canvasRect = canvas.getBoundingClientRect();
          const relativeX = this.x + canvasRect.left - svgRect.left;
          const relativeY = this.y + canvasRect.top - svgRect.top;
          const svgX = (relativeX / svgRect.width) * svgWidth;
          const svgY = (relativeY / svgRect.height) * svgHeight;
          return { x: svgX, y: svgY };
        }

        isInsideDiamond(svgX, svgY) {
          const centerX = 200, centerY = 200;
          const halfWidth = 120, halfHeight = 150;
          const normalizedDist = Math.abs(svgX - centerX) / halfWidth + Math.abs(svgY - centerY) / halfHeight;
          return normalizedDist <= 1;
        }

        isAtDiamondEdge(svgX, svgY) {
          const centerX = 200, centerY = 200;
          const halfWidth = 120, halfHeight = 150;
          const normalizedDist = Math.abs(svgX - centerX) / halfWidth + Math.abs(svgY - centerY) / halfHeight;
          return normalizedDist > 0.85 && normalizedDist <= 1.05;
        }

        update() {
          this.lifetime++;

          // Store trail position
          this.trail.push({ x: this.x, y: this.y });
          if (this.trail.length > this.maxTrailLength) {
            this.trail.shift();
          }

          // Mouse interaction - can be grabbed
          if (mouse.x !== null && mouse.y !== null) {
            const dx = mouse.x - this.x;
            const dy = mouse.y - this.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < mouse.radius || this.locked) {
              this.locked = true;
              const angle = Math.atan2(dy, dx);
              this.vx += Math.cos(angle) * 0.3;
              this.vy += Math.sin(angle) * 0.3;
            }
          } else {
            this.locked = false;
          }

          // Move at constant speed (no drag when not locked)
          this.x += this.vx;
          this.y += this.vy;

          // Only apply drag when locked to mouse (for controllability)
          if (this.locked) {
            this.vx *= 0.96;
            this.vy *= 0.96;
          }
          // When not locked, maintain constant velocity (straight line)

          // Check diamond collision
          const { x: svgX, y: svgY } = this.canvasToSvg();
          if (this.isInsideDiamond(svgX, svgY) || this.isAtDiamondEdge(svgX, svgY)) {
            if (this.locked) {
              return 'captured'; // Successfully caught!
            }
          }

          // Check if escaped (went off screen after entering)
          const buffer = 50;
          if (this.x < -buffer || this.x > canvas.width + buffer ||
              this.y < -buffer || this.y > canvas.height + buffer) {
            return 'escaped';
          }

          // Check if timed out
          if (this.lifetime > this.maxLifetime) {
            return 'escaped';
          }

          return 'active';
        }

        // Draw a 5-pointed star polygon
        drawStarShape(cx, cy, outerRadius, innerRadius, rotation = 0) {
          const points = 5;
          ctx.beginPath();
          for (let i = 0; i < points * 2; i++) {
            const radius = i % 2 === 0 ? outerRadius : innerRadius;
            const angle = (i * Math.PI / points) - Math.PI / 2 + rotation;
            const x = cx + Math.cos(angle) * radius;
            const y = cy + Math.sin(angle) * radius;
            if (i === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          }
          ctx.closePath();
        }

        draw() {
          // Rotation based on lifetime (gentle spin)
          const rotation = this.lifetime * 0.08;

          // Draw trail of mini stars
          for (let i = 0; i < this.trail.length; i++) {
            const t = this.trail[i];
            const alpha = (i / this.trail.length) * 0.6;
            const size = (i / this.trail.length) * this.radius * 0.7;
            const trailRotation = rotation - (this.trail.length - i) * 0.15;

            ctx.fillStyle = `rgba(255, 204, 0, ${alpha})`;
            this.drawStarShape(t.x, t.y, size, size * 0.4, trailRotation);
            ctx.fill();
          }

          // Draw star body with glow
          ctx.shadowColor = '#ffcc00';
          ctx.shadowBlur = 20;
          ctx.fillStyle = this.locked ? '#ffffff' : '#ffcc00';
          this.drawStarShape(this.x, this.y, this.radius * 2.5, this.radius, rotation);
          ctx.fill();

          // Inner bright core
          ctx.shadowBlur = 0;
          ctx.fillStyle = this.locked ? '#ffffff' : '#fff8dc';
          this.drawStarShape(this.x, this.y, this.radius * 1.2, this.radius * 0.5, rotation);
          ctx.fill();

          // Draw sparkle rays extending from points
          ctx.strokeStyle = `rgba(255, 255, 255, ${0.4 + Math.random() * 0.3})`;
          ctx.lineWidth = 1.5;
          for (let i = 0; i < 4; i++) {
            const rayAngle = rotation + (i * Math.PI / 2) + Math.PI / 4;
            const rayLength = this.radius * (2.5 + Math.random() * 1.5);
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(
              this.x + Math.cos(rayAngle) * rayLength,
              this.y + Math.sin(rayAngle) * rayLength
            );
            ctx.stroke();
          }

          // Reset canvas state
          ctx.lineWidth = 1;
          ctx.shadowBlur = 0;
        }
      }

      // Shooting stars array
      let shootingStars = [];

      // Spawn shooting stars at random intervals (5-15 seconds) - only one at a time
      function scheduleNextShootingStar() {
        const delay = 5000 + Math.random() * 10000; // 5-15 seconds
        setTimeout(() => {
          // Only spawn if no shooting star currently active
          if (lives > 0 && !gameOver && shootingStars.length === 0) {
            // Show warning
            shootingStarAlert.classList.add('visible');

            // Spawn after short warning
            setTimeout(() => {
              shootingStarAlert.classList.remove('visible');
              if (!gameOver && shootingStars.length === 0) {
                shootingStars.push(new ShootingStar());
              }
            }, 800);
          }
          scheduleNextShootingStar();
        }, delay);
      }

      // Start the shooting star spawner after initial delay
      setTimeout(scheduleNextShootingStar, 8000);

      // Main animation loop with shooting stars
      function animateWithShootingStars() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // If game over, just draw static particles and stop updates
        if (gameOver) {
          // Draw particles without updating them (frozen state)
          particles.forEach(particle => particle.draw());
          connectParticles();
          requestAnimationFrame(animateWithShootingStars);
          return;
        }

        // Respawn particles if below target count
        const now = Date.now();
        const targetCount = getTargetParticleCount();
        if (particles.length < targetCount && now - lastRespawnTime > respawnInterval) {
          particles.push(spawnParticleFromEdge());
          lastRespawnTime = now;
        }

        // Update particles and check for conversions
        particles = particles.filter(particle => {
          const shouldConvert = particle.update();

          if (shouldConvert) {
            conversionEffects.push(new ConversionEffect(particle.x, particle.y));
            if (window.createDiamondTracer) {
              window.createDiamondTracer(0);
              updateConversionCounter();
            }
            return false;
          }

          particle.draw();
          return true;
        });

        // Update shooting stars
        shootingStars = shootingStars.filter(star => {
          const status = star.update();

          if (status === 'captured') {
            // Success! +10 points - use special starburst effect
            starburstEffects.push(new StarburstEffect(star.x, star.y));
            if (window.createDiamondTracer) {
              window.createDiamondTracer(0);
              // Add 10 to score
              for (let i = 0; i < 10; i++) {
                updateConversionCounter();
              }
            }
            return false;
          } else if (status === 'escaped') {
            // Missed it - lose a life
            loseLife();
            return false;
          }

          star.draw();
          return true;
        });

        connectParticles();

        // Draw connections to shooting stars when grabbed
        shootingStars.forEach(star => {
          if (star.locked && mouse.x !== null && mouse.y !== null) {
            ctx.strokeStyle = 'rgba(255, 204, 0, 0.7)';
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            ctx.moveTo(star.x, star.y);
            ctx.lineTo(mouse.x, mouse.y);
            ctx.stroke();
          }
        });

        // Update and draw conversion effects
        conversionEffects = conversionEffects.filter(effect => {
          const isAlive = effect.update();
          effect.draw();
          return isAlive;
        });

        // Update and draw starburst effects (shooting star captures)
        starburstEffects = starburstEffects.filter(effect => {
          const isAlive = effect.update();
          effect.draw();
          return isAlive;
        });

        // Draw screen flash effect (fades out smoothly)
        if (screenFlash.active) {
          ctx.fillStyle = screenFlash.color + screenFlash.alpha + ')';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          screenFlash.alpha -= 0.02;
          if (screenFlash.alpha <= 0) {
            screenFlash.active = false;
          }
        }

        requestAnimationFrame(animateWithShootingStars);
      }

      // Start the animation loop
      animateWithShootingStars();
    </script>

    <!-- High Scores System -->
    <script type="module">
      // Supabase Configuration
      const SUPABASE_URL = 'https://yjoxvdetqeisnzzmzimp.supabase.co';
      const SUPABASE_ANON_KEY = 'sb_publishable_DZhyxoWxsXEIAlYD79tdfg_TnFJCZKp';

      // Import Supabase client
      import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm';

      // Initialize Supabase (will fail gracefully if credentials not set)
      let supabase = null;
      if (SUPABASE_URL !== 'https://yjoxvdetqeisnzzmzimp.supabase.co') {
        supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
      }

      // DOM Elements
      const highScoresPill = document.getElementById('high-scores-pill');
      const topScoreDisplay = document.getElementById('top-score-display');
      const highScoresModal = document.getElementById('high-scores-modal');
      const closeHighScores = document.getElementById('close-high-scores');
      const highScoresList = document.getElementById('high-scores-list');
      const gameOverScoresList = document.getElementById('game-over-scores-list');
      const initialsContainer = document.getElementById('initials-container');
      const initialsInput = document.getElementById('initials-input');
      const initialsSubmit = document.getElementById('initials-submit');

      // High scores cache
      let highScores = [];
      const MAX_SCORES = 10;

      // Fetch high scores from Supabase
      async function fetchHighScores() {
        if (!supabase) {
          console.log('Supabase not configured - using placeholder data');
          highScores = [
            { initials: 'ROB', score: 150 },
            { initials: 'AAA', score: 100 },
            { initials: 'ZZZ', score: 50 }
          ];
          updateHighScoresDisplay();
          return;
        }

        try {
          const { data, error } = await supabase
            .from('high_scores')
            .select('initials, score')
            .order('score', { ascending: false })
            .limit(MAX_SCORES);

          if (error) throw error;
          highScores = data || [];
          updateHighScoresDisplay();
        } catch (err) {
          console.error('Error fetching high scores:', err);
        }
      }

      // Submit a new high score
      async function submitHighScore(initials, score) {
        if (!supabase) {
          console.log('Supabase not configured - score not saved');
          // Add to local cache for demo purposes
          highScores.push({ initials: initials.toUpperCase(), score });
          highScores.sort((a, b) => b.score - a.score);
          highScores = highScores.slice(0, MAX_SCORES);
          updateHighScoresDisplay();
          return true;
        }

        try {
          const { error } = await supabase
            .from('high_scores')
            .insert([{ initials: initials.toUpperCase(), score }]);

          if (error) throw error;
          await fetchHighScores();
          return true;
        } catch (err) {
          console.error('Error submitting score:', err);
          return false;
        }
      }

      // Check if score qualifies for leaderboard
      function scoreQualifies(score) {
        if (score <= 0) return false;
        if (highScores.length < MAX_SCORES) return true;
        return score > highScores[highScores.length - 1].score;
      }

      // Update the high scores displays
      function updateHighScoresDisplay() {
        // Update top score on pill
        if (highScores.length > 0) {
          topScoreDisplay.textContent = highScores[0].score;
        } else {
          topScoreDisplay.textContent = '---';
        }

        // Update both score lists
        const listHTML = highScores.length > 0
          ? highScores.map((entry, i) => {
              let rankClass = '';
              if (i === 0) rankClass = 'gold';
              else if (i === 1) rankClass = 'silver';
              else if (i === 2) rankClass = 'bronze';
              return `<li>
                <span class="rank ${rankClass}">${i + 1}.</span>
                <span class="initials">${entry.initials}</span>
                <span class="score">${entry.score}</span>
              </li>`;
            }).join('')
          : '<li><span class="rank">-</span><span class="initials">---</span><span class="score">-</span></li>';

        highScoresList.innerHTML = listHTML;
        gameOverScoresList.innerHTML = listHTML;
      }

      // Show/hide high scores modal
      highScoresPill.addEventListener('click', () => {
        highScoresModal.classList.toggle('visible');
      });

      closeHighScores.addEventListener('click', () => {
        highScoresModal.classList.remove('visible');
      });

      // Close modal when clicking outside
      document.addEventListener('click', (e) => {
        if (!highScoresModal.contains(e.target) && !highScoresPill.contains(e.target)) {
          highScoresModal.classList.remove('visible');
        }
      });

      // Handle initials submission
      initialsSubmit.addEventListener('click', async () => {
        const initials = initialsInput.value.trim().toUpperCase();
        if (initials.length < 1 || initials.length > 3) {
          return;
        }

        initialsSubmit.disabled = true;
        initialsSubmit.textContent = '...';

        const score = parseInt(document.getElementById('final-score').textContent);
        const success = await submitHighScore(initials, score);

        if (success) {
          initialsContainer.classList.remove('visible');
          initialsInput.value = '';
        }

        initialsSubmit.disabled = false;
        initialsSubmit.textContent = 'Save';
      });

      // Allow enter key to submit
      initialsInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          initialsSubmit.click();
        }
      });

      // Expose function to show initials input on game over
      window.checkHighScore = function(score) {
        if (scoreQualifies(score)) {
          initialsContainer.classList.add('visible');
          setTimeout(() => initialsInput.focus(), 100);
        }
      };

      // Expose function to hide initials input on reset
      window.resetHighScoreInput = function() {
        initialsContainer.classList.remove('visible');
        initialsInput.value = '';
      };

      // Initial fetch
      fetchHighScores();
    </script>


    
</body>
</html>
